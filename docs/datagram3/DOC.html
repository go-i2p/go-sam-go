<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>datagram3 - go-i2p/go-sam-go</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <nav class="nav-sidebar">
    <div class="repo-info">
      <h2>
        <a href="../index.html">go-i2p/go-sam-go</a>
      </h2>
      <div class="repo-meta">
        üìù 189 commits
        
      </div>
    </div>
    
    <ul class="nav-links">
      <li><a href="../index.html">Repository Overview</a></li>
      
      
        <div class="nav-section-title">Documentation:</div>
        
          <li><a href="../docs/SAMv3.html" >SAM V3</a></li>
        
          <li><a href="../docs/common/DOC.html" >common</a></li>
        
          <li><a href="../docs/datagram/DOC.html" >datagram</a></li>
        
          <li><a href="../docs/datagram2/DOC.html" >datagram2</a></li>
        
          <li><a href="../docs/datagram3/DOC.html" class="active">datagram3</a></li>
        
          <li><a href="../docs/primary/DOC.html" >primary</a></li>
        
          <li><a href="../docs/raw/DOC.html" >raw</a></li>
        
          <li><a href="../docs/DOC.html" >sam3</a></li>
        
          <li><a href="../docs/sigs.html" >sam3</a></li>
        
          <li><a href="../docs/stream/DOC.html" >stream</a></li>
        
      
    </ul>
    
    <div class="nav-footer">
      <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a>
    </div>
  </nav>
  
  <div class="main-content">
    <header class="page-header">
      <h1>datagram3 - go-i2p/go-sam-go</h1>
    </header>
    
    <main>
      <div class="doc-content">
        <h1 id="datagram3">datagram3</h1>

<p>&ndash;</p>

<pre><code>import &quot;github.com/go-i2p/go-sam-go/datagram3&quot;
</code></pre>

<p>Package datagram3 provides repliable but UNAUTHENTICATED datagram sessions for
I2P.</p>

<h1 id="critical-security-warning">CRITICAL SECURITY WARNING</h1>

<p>‚ö†Ô∏è DATAGRAM3 sources are NOT authenticated and can be spoofed by malicious
actors!</p>

<p>‚ö†Ô∏è Any attacker can claim to be any sender by providing a fake hash.</p>

<p>‚ö†Ô∏è Do NOT trust source identity without additional application-level
authentication.</p>

<p>‚ö†Ô∏è If you need authenticated sources, use DATAGRAM2 instead.</p>

<h1 id="overview">Overview</h1>

<p>DATAGRAM3 provides UDP-like messaging over I2P with hash-based source
identification. This format prioritizes low overhead over source verification,
making it suitable for applications that implement their own authentication
layer or where source identity is not security-critical.</p>

<p>Key features:</p>

<pre><code>- Repliable datagrams (can send replies to sender)
- Unauthenticated sources (hash-based, spoofable)
- Offline signature support
- UDP-like messaging (unreliable, unordered)
- Maximum 31744 bytes (recommended 11 KB for reliability)
- Automatic hash-to-destination caching via NAMING LOOKUP
</code></pre>

<h1 id="key-differences-from-datagram-and-datagram2">Key Differences from DATAGRAM and DATAGRAM2</h1>

<pre><code>Feature              | DATAGRAM | DATAGRAM2 | DATAGRAM3
---------------------|----------|-----------|----------
Authenticated        | Yes      | Yes       | NO
Repliable            | Yes      | Yes       | Yes
Replay Protection    | No       | Yes       | No
Offline Signatures   | No       | Yes       | Yes
Source Format        | Full     | Full      | 32-byte hash
Source Verification  | Yes      | Yes       | NO
Reply Overhead       | Low      | Low       | Higher (NAMING LOOKUP)
</code></pre>

<h1 id="security-considerations">Security Considerations</h1>

<p>DATAGRAM3 is appropriate when:</p>

<pre><code>- Application implements its own authentication layer
- Source identity is not security-critical
- High-volume messaging requiring low overhead
- Anonymous bulletin boards or chat systems
- Telemetry or metrics collection
</code></pre>

<p>DATAGRAM3 is NOT appropriate for:</p>

<pre><code>- Financial transactions
- Identity-based access control
- Cryptographic protocols relying on source verification
- Any system where source spoofing has security implications
</code></pre>

<h1 id="i2p-timing-considerations">I2P Timing Considerations</h1>

<p>Session creation: 2-5 minutes for I2P tunnel establishment</p>

<p>Datagram delivery: Variable latency (network-dependent)</p>

<p>Hash resolution: Additional network round-trip for NAMING LOOKUP (cached after
first use)</p>

<p>Recommended: Use generous timeouts (5+ minutes for session creation) and retry
logic with exponential backoff. Distinguish between I2P network delays and
actual failures.</p>

<h1 id="basic-usage">Basic Usage</h1>

<p>Create a session:</p>

<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()
sam, err := common.NewSAM(&quot;127.0.0.1:7656&quot;)
session, err := datagram3.NewDatagram3Session(sam, &quot;my-session&quot;, keys, []string{&quot;inbound.length=1&quot;})
defer session.Close()
</code></pre>

<p>Receive datagrams with hash resolution:</p>

<pre><code>reader := session.NewReader()
go reader.receiveLoop()
for {
    dg, err := reader.ReceiveDatagram()
    if err != nil {
        log.Error(err)
        continue
    }
    // SECURITY: dg.SourceHash is UNAUTHENTICATED!
    log.Warn(&quot;Received from unverified hash:&quot;, hex.EncodeToString(dg.SourceHash))

    // Resolve hash to full destination for reply (cached after first lookup)
    if err := dg.ResolveSource(session); err != nil {
        log.Error(&quot;Failed to resolve:&quot;, err)
        continue
    }

    // Process data and reply (source still unverified!)
    writer := session.NewWriter()
    writer.SendDatagram([]byte(&quot;reply&quot;), dg.Source)
}
</code></pre>

<p>Send datagrams:</p>

<pre><code>writer := session.NewWriter().SetTimeout(30*time.Second)
err := writer.SendDatagram(data, destination)
</code></pre>

<h1 id="hash-resolution-for-replies">Hash Resolution for Replies</h1>

<p>Received DATAGRAM3 messages contain a 44-byte base64 hash (32 bytes binary)
instead of the full sender destination. To reply, the hash must be converted to
a b32.i2p address and resolved via NAMING LOOKUP:</p>

<pre><code>1. Receive 44-byte base64 hash from SAM bridge
2. Base64-decode to 32 bytes binary
3. Base32-encode to 52 characters
4. Append &quot;.b32.i2p&quot; suffix
5. Use resulting address for NAMING LOOKUP to get full destination
6. Cache full destination to avoid repeated lookups
7. Use full destination for SendDatagram()
</code></pre>

<p>The session maintains a HashResolver cache to minimize lookup overhead.
Applications replying to the same source repeatedly benefit from caching.</p>

<p>Example with manual hash handling:</p>

<pre><code>// Get b32 address without full resolution (fast, no network I/O)
b32Addr := datagram.GetSourceB32()
log.Info(&quot;Received from (unverified):&quot;, b32Addr)

// Check if already cached (no network I/O)
if dest, ok := session.resolver.GetCached(datagram.SourceHash); ok {
    writer.SendDatagram(reply, dest)
} else {
    // Resolve with network I/O
    if err := datagram.ResolveSource(session); err != nil {
        log.Error(err)
    }
}
</code></pre>

<h1 id="primary-session-usage">PRIMARY Session Usage</h1>

<p>DATAGRAM3 supports SAMv3.3 PRIMARY sessions for sharing tunnels across multiple
subsessions:</p>

<pre><code>primary, err := sam.NewPrimarySession(&quot;main&quot;, keys, options)
udpConn, _ := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr{IP: net.ParseIP(&quot;127.0.0.1&quot;), Port: 0})
sub1, err := datagram3.NewDatagram3SessionFromSubsession(sam, &quot;sub1&quot;, keys, options, udpConn)
</code></pre>

<p>Each subsession can use LISTEN_PORT to differentiate incoming datagrams.</p>

<h1 id="implementation-status">Implementation Status</h1>

<p>DATAGRAM3 is a new format specified in early 2025. This is one of the first
implementations. Check SAM bridge documentation for I2P router support (Java I2P
0.9.x+, i2pd 2.x+).</p>

<p>Current implementation status:</p>

<pre><code>- Core session management: ‚úÖ Implemented
- UDP forwarding: ‚úÖ Implemented
- Hash resolution and caching: ‚úÖ Implemented
- Send/receive operations: ‚úÖ Implemented
- PacketConn interface: ‚úÖ Implemented
- PRIMARY session integration: ‚è∏Ô∏è Deferred (low priority)
</code></pre>

<h1 id="attack-scenarios">Attack Scenarios</h1>

<p>Source Spoofing: Attacker claims to be legitimate sender by providing fake hash.
Applications trust unauthenticated source for security decisions. Mitigation:
Application-layer authentication required.</p>

<p>Cache Poisoning: Attacker floods with fake sources causing cache to grow
unbounded. Mitigation: Implement cache size limits and TTL (planned
enhancement).</p>

<p>Impersonation: Attacker replies pretending to be original sender. No
cryptographic verification of source identity. Mitigation: Use DATAGRAM2 for
authenticated sources.</p>

<h1 id="performance-considerations">Performance Considerations</h1>

<p>Hash resolution overhead: First reply to any source requires NAMING LOOKUP
(network I/O). Subsequent replies to same source use cached destination (fast).
Cache hit rate improves with repeated communication to same peers. Consider
pre-resolving known peers during initialization for critical paths.</p>

<p>Memory usage: Hash resolver cache grows unbounded. Monitor cache size with
CacheSize(). Consider implementing periodic cache clearing for long-running
applications. Future enhancement: LRU eviction policy and cache size limits.</p>

<h1 id="protocol-compliance">Protocol Compliance</h1>

<p>This implementation follows the SAMv3 specification for DATAGRAM3 sessions:</p>

<pre><code>- STYLE=DATAGRAM3 (not DATAGRAM or DATAGRAM2)
- UDP forwarding (PORT/HOST) is mandatory for SAMv3
- Supports SAM 3.2+ features (FROM_PORT/TO_PORT)
- Supports SAM 3.3+ features (SEND_TAGS, TAG_THRESHOLD, EXPIRES, SEND_LEASESET)
- Offline signature support via SIGNATURE_TYPE
- PRIMARY session subsession support
</code></pre>

<h1 id="see-also">See Also</h1>

<p>Package datagram: Legacy DATAGRAM sessions (authenticated, repliable)</p>

<p>Package datagram2: DATAGRAM2 sessions (authenticated, repliable, replay
protection)</p>

<p>Package stream: TCP-like reliable connections</p>

<p>Package raw: Encrypted but unauthenticated datagrams (non-repliable)</p>

<p>Package primary: PRIMARY session management for multiple subsessions</p>

<h2 id="usage">Usage</h2>

<h4 id="type-datagram3">type Datagram3</h4>

<pre><code class="language-go">type Datagram3 struct {
	Data       []byte          // Raw datagram payload (up to ~31KB)
	SourceHash []byte          // 32-byte UNAUTHENTICATED hash (spoofable!)
	Source     i2pkeys.I2PAddr // Resolved destination (nil until ResolveSource)
	Local      i2pkeys.I2PAddr // Local destination (this session)
}
</code></pre>

<p>Datagram3 represents an I2P datagram3 message with UNAUTHENTICATED source.</p>

<p>‚ö†Ô∏è CRITICAL SECURITY WARNING: SourceHash is NOT authenticated and can be
spoofed! ‚ö†Ô∏è Any malicious actor can claim to be any source by providing a fake
hash. ‚ö†Ô∏è Applications MUST implement their own authentication if source identity
matters. ‚ö†Ô∏è Use DATAGRAM2 if you need cryptographically authenticated sources.</p>

<p>This structure encapsulates the payload data along with the unauthenticated
source hash and optional resolved destination. The SourceHash is always present
(32 bytes), while Source is only populated after calling ResolveSource() to
perform NAMING LOOKUP.</p>

<p>Fields:</p>

<pre><code>- Data: Raw datagram payload (up to ~31KB)
- SourceHash: 32-byte UNAUTHENTICATED hash of sender (spoofable!)
- Source: Resolved full destination (nil until ResolveSource() called)
- Local: Local destination (this session)
</code></pre>

<p>Example usage:</p>

<pre><code>// Received datagram has only hash, not full source
log.Warn(&quot;Received from UNAUTHENTICATED hash:&quot;, hex.EncodeToString(dg.SourceHash))

// Resolve hash to full destination for reply
if err := dg.ResolveSource(session); err != nil {
    return err
}

// Now can reply using resolved source (still unverified!)
writer.SendDatagram(reply, dg.Source)
</code></pre>

<h4 id="func-datagram3-getsourceb32">func (*Datagram3) GetSourceB32</h4>

<pre><code class="language-go">func (d *Datagram3) GetSourceB32() string
</code></pre>

<p>GetSourceB32 returns the b32.i2p address for the source hash without full
resolution. This converts the 32-byte hash to a base32-encoded .b32.i2p address
string without performing NAMING LOOKUP. This is faster than full resolution and
sufficient for display, logging, or caching purposes.</p>

<p>‚ö†Ô∏è SECURITY WARNING: The returned address is still UNAUTHENTICATED! ‚ö†Ô∏è This
method does not add source verification.</p>

<p>Returns empty string if SourceHash is invalid (not 32 bytes).</p>

<p>Example usage:</p>

<pre><code>b32Addr := datagram.GetSourceB32()
log.Info(&quot;Received from (unverified):&quot;, b32Addr)
</code></pre>

<h4 id="func-datagram3-resolvesource">func (*Datagram3) ResolveSource</h4>

<pre><code class="language-go">func (d *Datagram3) ResolveSource(session *Datagram3Session) error
</code></pre>

<p>ResolveSource resolves the source hash to a full I2P destination for replying.
This performs a NAMING LOOKUP to convert the 32-byte hash into a full
destination address. The operation is cached in the session&rsquo;s resolver to avoid
repeated lookups.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Resolving the hash does NOT authenticate the source! ‚ö†Ô∏è
Even with full destination, the source can still be spoofed. ‚ö†Ô∏è This method only
enables replies, it does NOT verify identity.</p>

<p>Process:</p>

<pre><code>1. Check if already resolved (Source not nil)
2. Validate SourceHash is 32 bytes
3. Convert hash to b32.i2p address (base32 encoding)
4. Perform NAMING LOOKUP via SAM bridge
5. Cache result in session resolver
6. Populate Source field with full destination
</code></pre>

<p>This is an expensive operation (network round-trip) so results are cached.
Applications replying to the same source repeatedly benefit from caching.</p>

<p>Example usage:</p>

<pre><code>if err := datagram.ResolveSource(session); err != nil {
    log.Error(&quot;Failed to resolve source:&quot;, err)
    return err
}
// datagram.Source now contains full destination
</code></pre>

<h4 id="type-datagram3addr">type Datagram3Addr</h4>

<pre><code class="language-go">type Datagram3Addr struct {
}
</code></pre>

<p>Datagram3Addr implements net.Addr interface for I2P datagram3 addresses.</p>

<p>‚ö†Ô∏è SECURITY WARNING: If constructed from received hash, this address is
UNAUTHENTICATED! ‚ö†Ô∏è Do not trust the address for security-critical operations
without additional verification.</p>

<p>This type provides standard Go networking address representation for I2P
destinations, allowing seamless integration with existing Go networking code
that expects net.Addr. The address can wrap either a full I2P destination or
just a hash from reception.</p>

<p>Example usage:</p>

<pre><code>addr := &amp;Datagram3Addr{addr: destination, hash: sourceHash}
fmt.Println(addr.Network(), addr.String())
</code></pre>

<h4 id="func-datagram3addr-network">func (*Datagram3Addr) Network</h4>

<pre><code class="language-go">func (a *Datagram3Addr) Network() string
</code></pre>

<p>Network returns the network type for I2P datagram3 addresses. This implements
the net.Addr interface by returning &ldquo;datagram3&rdquo; as the network type.</p>

<h4 id="func-datagram3addr-string">func (*Datagram3Addr) String</h4>

<pre><code class="language-go">func (a *Datagram3Addr) String() string
</code></pre>

<p>String returns the string representation of the I2P address. This implements the
net.Addr interface. If a full address is available, returns base32
representation. If only hash is available, returns the b32.i2p derived address.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Hash-derived addresses are UNAUTHENTICATED!</p>

<h4 id="type-datagram3conn">type Datagram3Conn</h4>

<pre><code class="language-go">type Datagram3Conn struct {
}
</code></pre>

<p>Datagram3Conn implements net.PacketConn interface for I2P datagram3
communication.</p>

<p>‚ö†Ô∏è SECURITY WARNING: All sources received via this connection are
UNAUTHENTICATED! ‚ö†Ô∏è Applications MUST implement their own authentication layer
if source identity matters.</p>

<p>This type provides compatibility with standard Go networking patterns by
wrapping datagram3 session functionality in a familiar PacketConn interface. It
manages internal readers and writers while providing standard connection
operations.</p>

<p>The connection provides thread-safe concurrent access to I2P datagram3
operations and properly handles cleanup on close. Unlike DATAGRAM/DATAGRAM2,
sources are hash-based and not cryptographically verified.</p>

<p>Example usage:</p>

<pre><code>conn := session.PacketConn()
n, addr, err := conn.ReadFrom(buffer)
// addr represents UNAUTHENTICATED source!
n, err = conn.WriteTo(data, destination)
</code></pre>

<h4 id="func-datagram3conn-close">func (*Datagram3Conn) Close</h4>

<pre><code class="language-go">func (c *Datagram3Conn) Close() error
</code></pre>

<p>Close closes the datagram3 connection and releases associated resources. This
method implements the net.Conn interface. It closes the reader and writer but
does not close the underlying session, which may be shared by other connections.
Multiple calls to Close are safe and will return nil after the first call.</p>

<h4 id="func-datagram3conn-localaddr">func (*Datagram3Conn) LocalAddr</h4>

<pre><code class="language-go">func (c *Datagram3Conn) LocalAddr() net.Addr
</code></pre>

<p>LocalAddr returns the local network address as a Datagram3Addr containing the
I2P destination address of this connection&rsquo;s session. This method implements the
net.Conn interface and provides access to the local I2P destination.</p>

<h4 id="func-datagram3conn-read">func (*Datagram3Conn) Read</h4>

<pre><code class="language-go">func (c *Datagram3Conn) Read(b []byte) (n int, err error)
</code></pre>

<p>Read implements net.Conn by wrapping ReadFrom for stream-like usage. It reads
data into the provided byte slice and returns the number of bytes read. When
reading, it also updates the remote address of the connection for subsequent
Write calls.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Remote address is UNAUTHENTICATED hash-based!</p>

<p>Note: This is not typical for datagrams which are connectionless, but provides
compatibility with the net.Conn interface.</p>

<h4 id="func-datagram3conn-readfrom">func (*Datagram3Conn) ReadFrom</h4>

<pre><code class="language-go">func (c *Datagram3Conn) ReadFrom(p []byte) (n int, addr net.Addr, err error)
</code></pre>

<p>ReadFrom reads an UNAUTHENTICATED datagram from the connection.</p>

<p>‚ö†Ô∏è CRITICAL SECURITY WARNING: Source addresses are NOT authenticated! ‚ö†Ô∏è The
returned address contains an UNAUTHENTICATED hash-based source. ‚ö†Ô∏è Do not trust
source identity without additional verification.</p>

<p>This method implements the net.PacketConn interface. It starts the receive loop
if not already started and blocks until a datagram is received. The data is
copied to the provided buffer p, and the UNAUTHENTICATED source address is
returned as a Datagram3Addr.</p>

<p>The source address contains the 32-byte hash (not full destination).
Applications must resolve the hash via ResolveSource() to reply.</p>

<h4 id="func-datagram3conn-remoteaddr">func (*Datagram3Conn) RemoteAddr</h4>

<pre><code class="language-go">func (c *Datagram3Conn) RemoteAddr() net.Addr
</code></pre>

<p>RemoteAddr returns the remote network address of the connection. This method
implements the net.Conn interface. For datagram3 connections, this returns the
UNAUTHENTICATED address of the last peer that sent data (set by Read), or nil if
no data has been received yet.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Remote address is UNAUTHENTICATED!</p>

<h4 id="func-datagram3conn-setdeadline">func (*Datagram3Conn) SetDeadline</h4>

<pre><code class="language-go">func (c *Datagram3Conn) SetDeadline(t time.Time) error
</code></pre>

<p>SetDeadline sets both read and write deadlines for the connection. This method
implements the net.Conn interface by calling both SetReadDeadline and
SetWriteDeadline with the same time value. If either deadline cannot be set, the
first error encountered is returned.</p>

<h4 id="func-datagram3conn-setreaddeadline">func (*Datagram3Conn) SetReadDeadline</h4>

<pre><code class="language-go">func (c *Datagram3Conn) SetReadDeadline(t time.Time) error
</code></pre>

<p>SetReadDeadline sets the deadline for future ReadFrom calls. This method
implements the net.Conn interface. For datagram3 connections, this is currently
a placeholder implementation that always returns nil. Timeout handling is
managed differently for datagram operations.</p>

<h4 id="func-datagram3conn-setwritedeadline">func (*Datagram3Conn) SetWriteDeadline</h4>

<pre><code class="language-go">func (c *Datagram3Conn) SetWriteDeadline(t time.Time) error
</code></pre>

<p>SetWriteDeadline sets the deadline for future WriteTo calls. This method
implements the net.Conn interface. If the deadline is not zero, it calculates
the timeout duration and sets it on the writer for subsequent write operations.</p>

<h4 id="func-datagram3conn-write">func (*Datagram3Conn) Write</h4>

<pre><code class="language-go">func (c *Datagram3Conn) Write(b []byte) (n int, err error)
</code></pre>

<p>Write implements net.Conn by wrapping WriteTo for stream-like usage. It writes
data to the remote address set by the last Read operation and returns the number
of bytes written. If no remote address has been set, it returns an error. Note:
This is not typical for datagrams which are connectionless, but provides
compatibility with the net.Conn interface.</p>

<h4 id="func-datagram3conn-writeto">func (*Datagram3Conn) WriteTo</h4>

<pre><code class="language-go">func (c *Datagram3Conn) WriteTo(p []byte, addr net.Addr) (n int, err error)
</code></pre>

<p>WriteTo writes a datagram to the specified address. This method implements the
net.PacketConn interface. The address must be a Datagram3Addr or i2pkeys.I2PAddr
containing a valid I2P destination. The entire byte slice p is sent as a single
datagram message.</p>

<p>If the address is a Datagram3Addr with only a hash (not resolved), the hash will
be resolved automatically before sending.</p>

<h4 id="type-datagram3reader">type Datagram3Reader</h4>

<pre><code class="language-go">type Datagram3Reader struct {
}
</code></pre>

<p>Datagram3Reader handles incoming UNAUTHENTICATED datagram3 reception from I2P.</p>

<p>‚ö†Ô∏è SECURITY WARNING: All received datagrams have UNAUTHENTICATED sources! ‚ö†Ô∏è The
SourceHash field in received datagrams can be spoofed by attackers. ‚ö†Ô∏è Do not
trust source identity without additional verification.</p>

<p>The reader provides asynchronous datagram reception through buffered channels,
allowing applications to receive datagrams without blocking. It manages its own
goroutine for continuous message processing and provides thread-safe access to
received datagrams.</p>

<p>Unlike DATAGRAM/DATAGRAM2, sources are represented as 32-byte hashes rather than
full destinations. Applications must call ResolveSource() on received datagrams
to obtain the full destination for replies. The session&rsquo;s resolver cache
minimizes lookup overhead.</p>

<p>Example usage:</p>

<pre><code>reader := session.NewReader()
for {
    datagram, err := reader.ReceiveDatagram()
    if err != nil {
        // Handle error
    }
    // SECURITY: datagram.SourceHash is UNAUTHENTICATED!
    // Verify using application-layer authentication before trusting
    if err := datagram.ResolveSource(session); err != nil {
        // Handle resolution error
    }
    // Now datagram.Source contains full destination for reply
}
</code></pre>

<h4 id="func-datagram3reader-close">func (*Datagram3Reader) Close</h4>

<pre><code class="language-go">func (r *Datagram3Reader) Close() error
</code></pre>

<p>Close closes the Datagram3Reader and stops its receive loop. This method safely
terminates the reader, cleans up all associated resources, and signals any
waiting goroutines to stop. It&rsquo;s safe to call multiple times and will not block
if the reader is already closed.</p>

<p>Example usage:</p>

<pre><code>defer reader.Close()
</code></pre>

<h4 id="func-datagram3reader-receivedatagram">func (*Datagram3Reader) ReceiveDatagram</h4>

<pre><code class="language-go">func (r *Datagram3Reader) ReceiveDatagram() (*Datagram3, error)
</code></pre>

<p>ReceiveDatagram receives a single UNAUTHENTICATED datagram from the I2P network.</p>

<p>‚ö†Ô∏è CRITICAL SECURITY WARNING: Sources are NOT authenticated and can be spoofed!
‚ö†Ô∏è Do not trust datagram.SourceHash without additional verification. ‚ö†Ô∏è Use
application-layer authentication if source identity matters.</p>

<p>This method blocks until a datagram is received or an error occurs, returning
the received datagram with its data and UNAUTHENTICATED hash-based source. It
handles concurrent access safely and provides proper error handling for network
issues.</p>

<p>Unlike DATAGRAM/DATAGRAM2, received datagrams contain only a 32-byte hash (not
full destination). Applications must call ResolveSource() to convert the hash to
a full destination for replies.</p>

<p>Example usage:</p>

<pre><code>datagram, err := reader.ReceiveDatagram()
if err != nil {
    // Handle error
}
// SECURITY: datagram.SourceHash is UNAUTHENTICATED!
log.Warn(&quot;Received from unverified source:&quot;, hex.EncodeToString(datagram.SourceHash))
// Resolve hash for reply (expensive, cached)
if err := datagram.ResolveSource(session); err != nil {
    log.Error(err)
}
</code></pre>

<h4 id="type-datagram3session">type Datagram3Session</h4>

<pre><code class="language-go">type Datagram3Session struct {
	*common.BaseSession
}
</code></pre>

<p>Datagram3Session represents a repliable but UNAUTHENTICATED datagram3 session.</p>

<p>‚ö†Ô∏è CRITICAL SECURITY WARNING: Source addresses are NOT authenticated and can be
spoofed! ‚ö†Ô∏è Applications requiring source authentication MUST use DATAGRAM2
instead. ‚ö†Ô∏è Do NOT trust source identity without additional application-level
authentication.</p>

<p>DATAGRAM3 provides UDP-like messaging with hash-based source identification
instead of full authenticated destinations. This reduces overhead at the cost of
source verification. Received datagrams contain a 32-byte hash that requires
NAMING LOOKUP to resolve for replies.</p>

<p>Key differences from DATAGRAM/DATAGRAM2:</p>

<pre><code>- Repliable: Can reply to sender (like DATAGRAM/DATAGRAM2)
- Unauthenticated: Source is NOT verified (unlike DATAGRAM/DATAGRAM2)
- Hash-based source: 32-byte hash instead of full destination
- Lower overhead: No signature verification required
- Reply overhead: Requires NAMING LOOKUP to resolve hash
</code></pre>

<p>The session manages I2P tunnels and provides methods for creating readers and
writers. For SAMv3 mode, it uses UDP forwarding where datagrams are received via
a local UDP socket that the SAM bridge forwards to. The session maintains a hash
resolver cache to avoid repeated NAMING LOOKUP operations when replying to the
same source.</p>

<p>I2P Timing Considerations:</p>

<pre><code>- Session creation: 2-5 minutes for tunnel establishment
- Message delivery: Variable latency (network-dependent)
- Hash resolution: Additional network round-trip for NAMING LOOKUP
- Use generous timeouts and retry logic with exponential backoff
</code></pre>

<p>Example usage:</p>

<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()
session, err := NewDatagram3Session(sam, &quot;my-session&quot;, keys, options)
reader := session.NewReader()
dg, err := reader.ReceiveDatagram()
// dg.SourceHash is UNAUTHENTICATED - verify separately if needed!
if err := dg.ResolveSource(session); err != nil {
    log.Fatal(err)
}
session.NewWriter().SendDatagram(reply, dg.Source)
</code></pre>

<h4 id="func-newdatagram3session">func  NewDatagram3Session</h4>

<pre><code class="language-go">func NewDatagram3Session(sam *common.SAM, id string, keys i2pkeys.I2PKeys, options []string) (*Datagram3Session, error)
</code></pre>

<p>NewDatagram3Session creates a new repliable but UNAUTHENTICATED datagram3
session.</p>

<p>‚ö†Ô∏è CRITICAL SECURITY WARNING: DATAGRAM3 sources are NOT authenticated and can be
spoofed! ‚ö†Ô∏è Do not trust source addresses without additional application-level
authentication. ‚ö†Ô∏è If you need authenticated sources, use DATAGRAM2 instead.</p>

<p>This function establishes a new DATAGRAM3 session with the provided SAM
connection, session ID, cryptographic keys, and configuration options. It
automatically creates a UDP listener for receiving forwarded datagrams (SAMv3
requirement) and configures the session with PORT/HOST parameters.</p>

<p>DATAGRAM3 provides repliable datagrams with hash-based source identification:</p>

<pre><code>- Repliable: Can reply to sender (requires hash resolution via NAMING LOOKUP)
- Unauthenticated: Source is NOT verified (unlike DATAGRAM/DATAGRAM2)
- Hash-based source: 32-byte hash instead of full destination
- Lower overhead: No signature verification required
</code></pre>

<p>I2P Timing Considerations:</p>

<pre><code>- Session creation can take 2-5 minutes for I2P tunnel establishment
- Use context.WithTimeout with generous timeouts (5+ minutes recommended)
- Hash resolution adds network round-trip for replies (cached after first lookup)
- Implement exponential backoff retry logic for connection attempts
- Distinguish between I2P timing delays and actual failures
</code></pre>

<p>Example usage:</p>

<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()
session, err := NewDatagram3Session(sam, &quot;my-session&quot;, keys, []string{&quot;inbound.length=1&quot;})
reader := session.NewReader()
go reader.receiveLoop()
dg, err := reader.ReceiveDatagram()
// dg.SourceHash is UNAUTHENTICATED!
if err := dg.ResolveSource(session); err != nil {
    log.Fatal(err)
}
session.NewWriter().SendDatagram(reply, dg.Source)
</code></pre>

<h4 id="func-newdatagram3sessionfromsubsession">func  NewDatagram3SessionFromSubsession</h4>

<pre><code class="language-go">func NewDatagram3SessionFromSubsession(sam *common.SAM, id string, keys i2pkeys.I2PKeys, options []string, udpConn *net.UDPConn) (*Datagram3Session, error)
</code></pre>

<p>NewDatagram3SessionFromSubsession creates a Datagram3Session for a subsession
that has already been registered with a PRIMARY session using SESSION ADD. This
constructor skips the session creation step since the subsession is already
registered with the SAM bridge.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Subsession sources are UNAUTHENTICATED just like primary
session sources! ‚ö†Ô∏è Do not trust source addresses without additional
verification.</p>

<p>This function is specifically designed for use with SAMv3.3 PRIMARY sessions
where subsessions are created using SESSION ADD rather than SESSION CREATE
commands.</p>

<p>For PRIMARY datagram3 subsessions, UDP forwarding is mandatory (SAMv3
requirement). The UDP connection must be provided for proper datagram reception
via UDP forwarding.</p>

<p>DATAGRAM3 subsessions share the same cryptographic keys and I2P tunnels as the
PRIMARY session, but can be differentiated using LISTEN_PORT for incoming
datagram routing.</p>

<p>Parameters:</p>

<pre><code>- sam: SAM connection for data operations (separate from the primary session's control connection)
- id: The subsession ID that was already registered with SESSION ADD
- keys: The I2P keys from the primary session (shared across all subsessions)
- options: Configuration options for the subsession
- udpConn: UDP connection for receiving forwarded datagrams (required, not nil)
</code></pre>

<p>Returns a Datagram3Session ready for use without attempting to create a new SAM
session.</p>

<p>Example usage with PRIMARY session:</p>

<pre><code>primary, err := sam.NewPrimarySession(&quot;main&quot;, keys, options)
udpConn, _ := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr{IP: net.ParseIP(&quot;127.0.0.1&quot;), Port: 0})
sub, err := NewDatagram3SessionFromSubsession(sam, &quot;sub1&quot;, keys, options, udpConn)
</code></pre>

<h4 id="func-datagram3session-addr">func (*Datagram3Session) Addr</h4>

<pre><code class="language-go">func (s *Datagram3Session) Addr() i2pkeys.I2PAddr
</code></pre>

<p>Addr returns the local I2P address of this datagram3 session. This is the
destination address that other I2P nodes can use to send datagrams to this
session.</p>

<h4 id="func-datagram3session-close">func (*Datagram3Session) Close</h4>

<pre><code class="language-go">func (s *Datagram3Session) Close() error
</code></pre>

<p>Close terminates the datagram3 session and cleans up all resources. This method
ensures proper cleanup of the UDP connection and I2P tunnels. After calling
Close(), the session cannot be reused.</p>

<p>Example usage:</p>

<pre><code>defer session.Close()
</code></pre>

<h4 id="func-datagram3session-newreader">func (*Datagram3Session) NewReader</h4>

<pre><code class="language-go">func (s *Datagram3Session) NewReader() *Datagram3Reader
</code></pre>

<p>NewReader creates a Datagram3Reader for receiving UNAUTHENTICATED datagrams.</p>

<p>‚ö†Ô∏è SECURITY WARNING: All datagrams received have UNAUTHENTICATED sources! ‚ö†Ô∏è Do
not trust source identity without additional verification.</p>

<p>This method initializes a new reader with buffered channels for asynchronous
datagram reception. The reader must be started manually with receiveLoop() for
continuous operation.</p>

<p>Unlike DATAGRAM/DATAGRAM2, received datagrams contain 32-byte hashes rather than
full destinations. Applications must call ResolveSource() on received datagrams
to obtain the full destination for replies. The session&rsquo;s resolver cache
minimizes lookup overhead.</p>

<p>Example usage:</p>

<pre><code>reader := session.NewReader()
go reader.receiveLoop()
for {
    datagram, err := reader.ReceiveDatagram()
    if err != nil {
        // Handle error
    }
    // SECURITY: datagram.SourceHash is UNAUTHENTICATED!
    // Verify using application-layer authentication before trusting
    if err := datagram.ResolveSource(session); err != nil {
        // Handle resolution error
    }
    // Process datagram.Data
}
</code></pre>

<h4 id="func-datagram3session-newwriter">func (*Datagram3Session) NewWriter</h4>

<pre><code class="language-go">func (s *Datagram3Session) NewWriter() *Datagram3Writer
</code></pre>

<p>NewWriter creates a Datagram3Writer for sending datagrams to I2P destinations.
This method initializes a new writer with a default timeout of 30 seconds for
send operations. The timeout can be customized using the SetTimeout method on
the returned writer.</p>

<p>Destinations can be specified as full base64 destinations, hostnames (.i2p), or
b32 addresses. This includes b32 addresses derived from received DATAGRAM3
hashes after resolution.</p>

<p>Maximum datagram size is 31744 bytes total (including headers), with 11 KB
recommended for best reliability across the I2P network.</p>

<p>Example usage:</p>

<pre><code>writer := session.NewWriter().SetTimeout(60*time.Second)
err := writer.SendDatagram(data, destination)
</code></pre>

<h4 id="func-datagram3session-packetconn">func (*Datagram3Session) PacketConn</h4>

<pre><code class="language-go">func (s *Datagram3Session) PacketConn() net.PacketConn
</code></pre>

<p>PacketConn returns a net.PacketConn interface for this datagram3 session. This
method provides compatibility with standard Go networking code by wrapping the
datagram3 session in a PacketConn interface. The returned connection manages its
own reader and writer and implements all standard net.PacketConn methods.</p>

<p>‚ö†Ô∏è SECURITY WARNING: All sources are UNAUTHENTICATED! ‚ö†Ô∏è Do not trust addresses
received via ReadFrom without verification.</p>

<p>The connection is automatically cleaned up by a finalizer if Close() is not
called, but explicit Close() calls are strongly recommended to prevent resource
leaks.</p>

<p>Example usage:</p>

<pre><code>conn := session.PacketConn()
defer conn.Close()

// Receive with UNAUTHENTICATED source
n, addr, err := conn.ReadFrom(buffer)
// addr is UNAUTHENTICATED!

// Send reply
n, err = conn.WriteTo(reply, addr)
</code></pre>

<h4 id="type-datagram3writer">type Datagram3Writer</h4>

<pre><code class="language-go">type Datagram3Writer struct {
}
</code></pre>

<p>Datagram3Writer handles outgoing datagram3 transmission to I2P destinations. It
provides methods for sending datagrams with configurable timeouts and handles
the underlying SAM protocol communication for message delivery. The writer
supports method chaining for configuration and provides error handling for send
operations.</p>

<p>Maximum datagram size is 31744 bytes total (including headers), with 11 KB
recommended for best reliability. Destinations can be specified as full base64
destinations, hostnames (.i2p), or b32 addresses.</p>

<p>Example usage:</p>

<pre><code>writer := session.NewWriter().SetTimeout(30*time.Second)
err := writer.SendDatagram(data, destination)
</code></pre>

<h4 id="func-datagram3writer-replytodatagram">func (*Datagram3Writer) ReplyToDatagram</h4>

<pre><code class="language-go">func (w *Datagram3Writer) ReplyToDatagram(data []byte, original *Datagram3) error
</code></pre>

<p>ReplyToDatagram sends a reply to a received DATAGRAM3 message.</p>

<p>This automatically resolves the source hash if not already resolved, then sends
the reply. The source hash is resolved via NAMING LOOKUP and cached to avoid
repeated lookups.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Even after resolution, the source is still UNAUTHENTICATED!
‚ö†Ô∏è Do not trust the reply destination without additional verification.</p>

<p>Example usage:</p>

<pre><code>// Receive datagram
dg, err := reader.ReceiveDatagram()
if err != nil {
    return err
}

// Reply (automatically resolves hash)
writer := session.NewWriter()
err = writer.ReplyToDatagram([]byte(&quot;reply&quot;), dg)
</code></pre>

<h4 id="func-datagram3writer-senddatagram">func (*Datagram3Writer) SendDatagram</h4>

<pre><code class="language-go">func (w *Datagram3Writer) SendDatagram(data []byte, dest i2pkeys.I2PAddr) error
</code></pre>

<p>SendDatagram sends a datagram to the specified I2P destination.</p>

<p>This method uses the SAMv3 UDP approach: sending via UDP socket to port 7655
with DATAGRAM3 format. The destination can be:</p>

<pre><code>- Full base64 destination (516+ chars)
- Hostname (.i2p address)
- B32 address (52 chars + .b32.i2p)
- B32 address derived from received DATAGRAM3 hash (via ResolveSource)
</code></pre>

<p>Maximum datagram size is 31744 bytes total (including headers), with 11 KB
recommended for best reliability across the I2P network. It blocks until the
datagram is sent or an error occurs, respecting the configured timeout.</p>

<p>Example usage:</p>

<pre><code>// Send to full destination
err := writer.SendDatagram([]byte(&quot;hello world&quot;), destinationAddr)

// Reply to received datagram (requires hash resolution)
if err := receivedDatagram.ResolveSource(session); err != nil {
    return err
}
err := writer.SendDatagram([]byte(&quot;reply&quot;), receivedDatagram.Source)
</code></pre>

<h4 id="func-datagram3writer-settimeout">func (*Datagram3Writer) SetTimeout</h4>

<pre><code class="language-go">func (w *Datagram3Writer) SetTimeout(timeout time.Duration) *Datagram3Writer
</code></pre>

<p>SetTimeout sets the timeout for datagram3 write operations. This method
configures the maximum time to wait for datagram send operations to complete.
The timeout prevents indefinite blocking during network congestion or connection
issues. Returns the writer instance for method chaining convenience.</p>

<p>Example usage:</p>

<pre><code>writer.SetTimeout(30*time.Second).SendDatagram(data, destination)
</code></pre>

<h4 id="type-hashresolver">type HashResolver</h4>

<pre><code class="language-go">type HashResolver struct {
}
</code></pre>

<p>HashResolver provides caching for hash-to-destination lookups via NAMING LOOKUP.
This prevents repeated network queries for the same hash, which is critical for
DATAGRAM3 performance since every received datagram contains only a hash.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Resolving hashes does NOT authenticate sources! ‚ö†Ô∏è Even
with cached full destinations, sources remain UNAUTHENTICATED. ‚ö†Ô∏è Cache entries
are based on hash values which can be spoofed.</p>

<p>The resolver maintains an in-memory cache mapping b32.i2p addresses to full I2P
destinations. This cache is thread-safe using RWMutex and grows unbounded
(applications should monitor memory usage for long-running sessions receiving
from many sources).</p>

<p>Hash Resolution Process:</p>

<pre><code>1. Convert 32-byte hash to base32 (52 characters)
2. Append &quot;.b32.i2p&quot; suffix
3. Check cache for existing entry
4. If not cached, perform NAMING LOOKUP via SAM bridge
5. Cache successful result
6. Return full I2P destination
</code></pre>

<p>Example usage:</p>

<pre><code>resolver := NewHashResolver(sam)
dest, err := resolver.ResolveHash(hashBytes)
if err != nil {
    log.Error(&quot;Resolution failed:&quot;, err)
}
</code></pre>

<h4 id="func-newhashresolver">func  NewHashResolver</h4>

<pre><code class="language-go">func NewHashResolver(sam *common.SAM) *HashResolver
</code></pre>

<p>NewHashResolver creates a new hash resolver with empty cache. The resolver uses
the provided SAM connection for NAMING LOOKUP operations when cache misses
occur.</p>

<p>Example usage:</p>

<pre><code>resolver := NewHashResolver(sam)
</code></pre>

<h4 id="func-hashresolver-cachesize">func (*HashResolver) CacheSize</h4>

<pre><code class="language-go">func (r *HashResolver) CacheSize() int
</code></pre>

<p>CacheSize returns the current number of cached entries. This is useful for
monitoring memory usage and cache effectiveness.</p>

<p>Example usage:</p>

<pre><code>size := resolver.CacheSize()
log.Info(&quot;Cache contains&quot;, size, &quot;entries&quot;)
</code></pre>

<h4 id="func-hashresolver-clear">func (*HashResolver) Clear</h4>

<pre><code class="language-go">func (r *HashResolver) Clear()
</code></pre>

<p>Clear removes all cached entries. This is useful for testing, memory management
in long-running sessions, or when you want to force fresh NAMING LOOKUP
operations.</p>

<p>‚ö†Ô∏è WARNING: Clearing cache will cause subsequent resolutions to perform network
I/O. ‚ö†Ô∏è Only clear cache if necessary (testing, memory pressure, or security
concerns).</p>

<p>Applications with memory constraints may want to implement periodic cache
clearing or LRU eviction policies on top of this basic cache.</p>

<p>Example usage:</p>

<pre><code>// Clear cache after processing batch
resolver.Clear()

// Or clear periodically
ticker := time.NewTicker(1 * time.Hour)
go func() {
    for range ticker.C {
        resolver.Clear()
    }
}()
</code></pre>

<h4 id="func-hashresolver-getcached">func (*HashResolver) GetCached</h4>

<pre><code class="language-go">func (r *HashResolver) GetCached(hash []byte) (i2pkeys.I2PAddr, bool)
</code></pre>

<p>GetCached returns cached destination without performing lookup. This allows
checking if a hash has been previously resolved without triggering a potentially
expensive NAMING LOOKUP operation.</p>

<p>Returns:</p>

<pre><code>- destination: Full I2P destination if cached
- found: true if entry exists in cache, false otherwise
</code></pre>

<p>This method is useful for applications that want to avoid network I/O and only
use already-resolved destinations. It&rsquo;s also useful for testing cache behavior.</p>

<p>Example usage:</p>

<pre><code>if dest, ok := resolver.GetCached(hash); ok {
    // Use cached destination without network lookup
    writer.SendDatagram(reply, dest)
} else {
    // Hash not yet resolved - decide whether to resolve now
    log.Info(&quot;Hash not in cache, resolution required for reply&quot;)
}
</code></pre>

<h4 id="func-hashresolver-resolvehash">func (*HashResolver) ResolveHash</h4>

<pre><code class="language-go">func (r *HashResolver) ResolveHash(hash []byte) (i2pkeys.I2PAddr, error)
</code></pre>

<p>ResolveHash converts a 32-byte hash to a full I2P destination using NAMING
LOOKUP.</p>

<p>‚ö†Ô∏è SECURITY WARNING: This does NOT authenticate the source! ‚ö†Ô∏è Resolution only
enables replies, it does NOT verify identity. ‚ö†Ô∏è Malicious actors can provide
hashes that resolve to attacker-controlled destinations.</p>

<p>Process:</p>

<pre><code>1. Validate hash is exactly 32 bytes
2. Convert to b32.i2p address (base32 encoding + suffix)
3. Check cache for existing result
4. If cached, return immediately (fast path)
5. If not cached, perform NAMING LOOKUP (slow path, network I/O)
6. Cache successful result for future lookups
7. Return full destination
</code></pre>

<p>This is an expensive operation on cache misses due to network round-trip to I2P
router. Applications should minimize unnecessary resolutions by caching at
application level or reusing the same session resolver.</p>

<p>Error conditions:</p>

<pre><code>- Invalid hash length (not 32 bytes)
- Base32 encoding failure (malformed hash)
- NAMING LOOKUP failure (hash not resolvable, network error, etc.)
</code></pre>

<p>Example usage:</p>

<pre><code>dest, err := resolver.ResolveHash(datagram.SourceHash)
if err != nil {
    log.Error(&quot;Failed to resolve hash:&quot;, err)
    return err
}
// dest contains full I2P destination (still unverified!)
writer.SendDatagram(reply, dest)
</code></pre>

<h4 id="type-sam">type SAM</h4>

<pre><code class="language-go">type SAM struct {
	*common.SAM
}
</code></pre>

<p>SAM wraps common.SAM to provide datagram3-specific functionality for I2P
messaging. This type extends the base SAM functionality with methods
specifically designed for DATAGRAM3 communication, providing repliable but
UNAUTHENTICATED datagrams with hash-based source identification.</p>

<p>‚ö†Ô∏è SECURITY WARNING: DATAGRAM3 sources are NOT authenticated and can be spoofed!
‚ö†Ô∏è Do not trust source addresses without additional application-level
authentication. ‚ö†Ô∏è If you need authenticated sources, use DATAGRAM2 instead.</p>

<p>DATAGRAM3 uses 32-byte hashes instead of full destinations for source
identification, reducing overhead at the cost of source verification.
Applications requiring source authentication MUST implement their own
authentication layer.</p>

<p>Example usage: sam := &amp;SAM{SAM: baseSAM}; session, err :=
sam.NewDatagram3Session(id, keys, options)</p>

<h4 id="func-sam-newdatagram3session">func (*SAM) NewDatagram3Session</h4>

<pre><code class="language-go">func (s *SAM) NewDatagram3Session(id string, keys i2pkeys.I2PKeys, options []string) (*Datagram3Session, error)
</code></pre>

<p>NewDatagram3Session creates a new repliable but UNAUTHENTICATED datagram3
session. This method establishes a new DATAGRAM3 session for UDP-like messaging
over I2P with hash-based source identification. Session creation can take 2-5
minutes due to I2P tunnel establishment, so generous timeouts are recommended.</p>

<p>‚ö†Ô∏è SECURITY WARNING: DATAGRAM3 sources are NOT authenticated and can be spoofed!
‚ö†Ô∏è Applications requiring source authentication should use DATAGRAM2 instead.</p>

<p>DATAGRAM3 provides repliable datagrams with minimal overhead by using hash-based
source identification instead of full authenticated destinations. Received
datagrams contain a 32-byte hash that must be resolved via NAMING LOOKUP to
reply. The session maintains a cache to avoid repeated lookups.</p>

<p>Key differences from DATAGRAM and DATAGRAM2:</p>

<pre><code>- Repliable: Can reply to sender (like DATAGRAM/DATAGRAM2)
- Unauthenticated: Source is NOT verified (unlike DATAGRAM/DATAGRAM2)
- Hash-based: Source is 32-byte hash, NOT full destination
- Lower overhead: No signature verification required
- Reply requires NAMING LOOKUP: Hash must be resolved to full destination
</code></pre>

<p>Example usage:</p>

<pre><code>ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()
session, err := sam.NewDatagram3Session(&quot;my-session&quot;, keys, []string{&quot;inbound.length=1&quot;})
</code></pre>

<h4 id="func-sam-newdatagram3sessionwithports">func (*SAM) NewDatagram3SessionWithPorts</h4>

<pre><code class="language-go">func (s *SAM) NewDatagram3SessionWithPorts(id, fromPort, toPort string, keys i2pkeys.I2PKeys, options []string) (*Datagram3Session, error)
</code></pre>

<p>NewDatagram3SessionWithPorts creates a new datagram3 session with port
specifications. This method allows configuring specific I2CP port ranges for the
session, enabling fine-grained control over network communication ports for
advanced routing scenarios. Port configuration is useful for applications
requiring specific port mappings or PRIMARY session subsessions. This function
automatically creates a UDP listener for SAMv3 UDP forwarding (required for v3
mode).</p>

<p>‚ö†Ô∏è SECURITY WARNING: Port configuration does NOT add source authentication to
DATAGRAM3! ‚ö†Ô∏è Sources remain unauthenticated regardless of port settings.</p>

<p>The FROM_PORT and TO_PORT parameters specify I2CP ports for protocol-level
communication, distinct from the UDP forwarding port which is auto-assigned by
the OS.</p>

<p>Example usage:</p>

<pre><code>session, err := sam.NewDatagram3SessionWithPorts(id, &quot;8080&quot;, &quot;8081&quot;, keys, options)
</code></pre>

<h4 id="func-sam-newdatagram3sessionwithsignature">func (*SAM) NewDatagram3SessionWithSignature</h4>

<pre><code class="language-go">func (s *SAM) NewDatagram3SessionWithSignature(id string, keys i2pkeys.I2PKeys, options []string, sigType string) (*Datagram3Session, error)
</code></pre>

<p>NewDatagram3SessionWithSignature creates a new datagram3 session with custom
signature type. This method allows specifying a custom cryptographic signature
type for the session, enabling advanced security configurations beyond the
default Ed25519 algorithm. DATAGRAM3 supports offline signatures, allowing
pre-signed destinations for enhanced privacy and key management flexibility.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Custom signature types do NOT add source authentication to
DATAGRAM3! ‚ö†Ô∏è Sources remain unauthenticated regardless of signature
configuration.</p>

<p>Different signature types provide various security levels for the local
destination:</p>

<pre><code>- Ed25519 (type 7) - Recommended for most applications
- ECDSA (types 1-3) - Legacy compatibility
- RedDSA (type 11) - Advanced privacy features
</code></pre>

<p>Example usage:</p>

<pre><code>session, err := sam.NewDatagram3SessionWithSignature(id, keys, options, &quot;EdDSA_SHA512_Ed25519&quot;)
</code></pre>

      </div>
    </main>
    
    <footer class="page-footer">
      <p>Generated on 2025-10-09 10:13:57 ‚Ä¢ <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a></p>
    </footer>
  </div>
</body>
</html>