<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sam3 - go-i2p/go-sam-go</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <nav class="nav-sidebar">
    <div class="repo-info">
      <h2>
        <a href="../index.html">go-i2p/go-sam-go</a>
      </h2>
      <div class="repo-meta">
        üìù 215 commits
        
      </div>
    </div>
    
    <ul class="nav-links">
      <li><a href="../index.html">Repository Overview</a></li>
      
      
        <div class="nav-section-title">Documentation:</div>
        
          <li><a href="../docs/SAMv3.html" >SAM V3</a></li>
        
          <li><a href="../docs/common/DOC.html" >common</a></li>
        
          <li><a href="../docs/datagram/DOC.html" >datagram</a></li>
        
          <li><a href="../docs/datagram2/DOC.html" >datagram2</a></li>
        
          <li><a href="../docs/datagram3/DOC.html" >datagram3</a></li>
        
          <li><a href="../docs/primary/DOC.html" >primary</a></li>
        
          <li><a href="../docs/raw/DOC.html" >raw</a></li>
        
          <li><a href="../docs/sigs.html" class="active">sam3</a></li>
        
          <li><a href="../docs/DOC.html" >sam3</a></li>
        
          <li><a href="../docs/stream/DOC.html" >stream</a></li>
        
      
    </ul>
    
    <div class="nav-footer">
      <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a>
    </div>
  </nav>
  
  <div class="main-content">
    <header class="page-header">
      <h1>sam3 - go-i2p/go-sam-go</h1>
    </header>
    
    <main>
      <div class="doc-content">
        <h1 id="sam3">sam3</h1>

<p>&ndash;</p>

<pre><code>import &quot;github.com/go-i2p/sam3&quot;
</code></pre>

<p>Library for I2Ps SAMv3 bridge (<a href="https://geti2p.com" target="_blank">https://geti2p.com</a>)</p>

<h2 id="usage">Usage</h2>

<pre><code class="language-go">const (
	Sig_NONE                 = &quot;SIGNATURE_TYPE=EdDSA_SHA512_Ed25519&quot;
	Sig_DSA_SHA1             = &quot;SIGNATURE_TYPE=DSA_SHA1&quot;
	Sig_ECDSA_SHA256_P256    = &quot;SIGNATURE_TYPE=ECDSA_SHA256_P256&quot;
	Sig_ECDSA_SHA384_P384    = &quot;SIGNATURE_TYPE=ECDSA_SHA384_P384&quot;
	Sig_ECDSA_SHA512_P521    = &quot;SIGNATURE_TYPE=ECDSA_SHA512_P521&quot;
	Sig_EdDSA_SHA512_Ed25519 = &quot;SIGNATURE_TYPE=EdDSA_SHA512_Ed25519&quot;
)
</code></pre>

<pre><code class="language-go">var (
	// Suitable options if you are shuffling A LOT of traffic. If unused, this
	// will waste your resources.
	Options_Humongous = []string{&quot;inbound.length=3&quot;, &quot;outbound.length=3&quot;,
		&quot;inbound.lengthVariance=1&quot;, &quot;outbound.lengthVariance=1&quot;,
		&quot;inbound.backupQuantity=3&quot;, &quot;outbound.backupQuantity=3&quot;,
		&quot;inbound.quantity=6&quot;, &quot;outbound.quantity=6&quot;}

	// Suitable for shuffling a lot of traffic.
	Options_Large = []string{&quot;inbound.length=3&quot;, &quot;outbound.length=3&quot;,
		&quot;inbound.lengthVariance=1&quot;, &quot;outbound.lengthVariance=1&quot;,
		&quot;inbound.backupQuantity=1&quot;, &quot;outbound.backupQuantity=1&quot;,
		&quot;inbound.quantity=4&quot;, &quot;outbound.quantity=4&quot;}

	// Suitable for shuffling a lot of traffic quickly with minimum
	// anonymity. Uses 1 hop and multiple tunnels.
	Options_Wide = []string{&quot;inbound.length=1&quot;, &quot;outbound.length=1&quot;,
		&quot;inbound.lengthVariance=1&quot;, &quot;outbound.lengthVariance=1&quot;,
		&quot;inbound.backupQuantity=2&quot;, &quot;outbound.backupQuantity=2&quot;,
		&quot;inbound.quantity=3&quot;, &quot;outbound.quantity=3&quot;}

	// Suitable for shuffling medium amounts of traffic.
	Options_Medium = []string{&quot;inbound.length=3&quot;, &quot;outbound.length=3&quot;,
		&quot;inbound.lengthVariance=1&quot;, &quot;outbound.lengthVariance=1&quot;,
		&quot;inbound.backupQuantity=0&quot;, &quot;outbound.backupQuantity=0&quot;,
		&quot;inbound.quantity=2&quot;, &quot;outbound.quantity=2&quot;}

	// Sensible defaults for most people
	Options_Default = []string{&quot;inbound.length=3&quot;, &quot;outbound.length=3&quot;,
		&quot;inbound.lengthVariance=0&quot;, &quot;outbound.lengthVariance=0&quot;,
		&quot;inbound.backupQuantity=1&quot;, &quot;outbound.backupQuantity=1&quot;,
		&quot;inbound.quantity=1&quot;, &quot;outbound.quantity=1&quot;}

	// Suitable only for small dataflows, and very short lasting connections:
	// You only have one tunnel in each direction, so if any of the nodes
	// through which any of your two tunnels pass through go offline, there will
	// be a complete halt in the dataflow, until a new tunnel is built.
	Options_Small = []string{&quot;inbound.length=3&quot;, &quot;outbound.length=3&quot;,
		&quot;inbound.lengthVariance=1&quot;, &quot;outbound.lengthVariance=1&quot;,
		&quot;inbound.backupQuantity=0&quot;, &quot;outbound.backupQuantity=0&quot;,
		&quot;inbound.quantity=1&quot;, &quot;outbound.quantity=1&quot;}

	// Does not use any anonymization, you connect directly to others tunnel
	// endpoints, thus revealing your identity but not theirs. Use this only
	// if you don't care.
	Options_Warning_ZeroHop = []string{&quot;inbound.length=0&quot;, &quot;outbound.length=0&quot;,
		&quot;inbound.lengthVariance=0&quot;, &quot;outbound.lengthVariance=0&quot;,
		&quot;inbound.backupQuantity=0&quot;, &quot;outbound.backupQuantity=0&quot;,
		&quot;inbound.quantity=2&quot;, &quot;outbound.quantity=2&quot;}
)
</code></pre>

<p>Examples and suggestions for options when creating sessions.</p>

<pre><code class="language-go">var PrimarySessionSwitch string = PrimarySessionString()
</code></pre>

<pre><code class="language-go">var SAM_HOST = getEnv(&quot;sam_host&quot;, &quot;127.0.0.1&quot;)
</code></pre>

<pre><code class="language-go">var SAM_PORT = getEnv(&quot;sam_port&quot;, &quot;7656&quot;)
</code></pre>

<h4 id="func-extractdest">func  ExtractDest</h4>

<pre><code class="language-go">func ExtractDest(input string) string
</code></pre>

<h4 id="func-extractpairint">func  ExtractPairInt</h4>

<pre><code class="language-go">func ExtractPairInt(input, value string) int
</code></pre>

<h4 id="func-extractpairstring">func  ExtractPairString</h4>

<pre><code class="language-go">func ExtractPairString(input, value string) string
</code></pre>

<h4 id="func-generateoptionstring">func  GenerateOptionString</h4>

<pre><code class="language-go">func GenerateOptionString(opts []string) string
</code></pre>

<h4 id="func-getsam3logger">func  GetSAM3Logger</h4>

<pre><code class="language-go">func GetSAM3Logger() *logrus.Logger
</code></pre>

<p>GetSAM3Logger returns the initialized logger</p>

<h4 id="func-ignoreporterror">func  IgnorePortError</h4>

<pre><code class="language-go">func IgnorePortError(err error) error
</code></pre>

<h4 id="func-initializesam3logger">func  InitializeSAM3Logger</h4>

<pre><code class="language-go">func InitializeSAM3Logger()
</code></pre>

<h4 id="func-primarysessionstring">func  PrimarySessionString</h4>

<pre><code class="language-go">func PrimarySessionString() string
</code></pre>

<h4 id="func-randstring">func  RandString</h4>

<pre><code class="language-go">func RandString() string
</code></pre>

<h4 id="func-samdefaultaddr">func  SAMDefaultAddr</h4>

<pre><code class="language-go">func SAMDefaultAddr(fallforward string) string
</code></pre>

<h4 id="func-setaccesslist">func  SetAccessList</h4>

<pre><code class="language-go">func SetAccessList(s []string) func(*SAMEmit) error
</code></pre>

<p>SetAccessList tells the system to treat the AccessList as a whitelist</p>

<h4 id="func-setaccesslisttype">func  SetAccessListType</h4>

<pre><code class="language-go">func SetAccessListType(s string) func(*SAMEmit) error
</code></pre>

<p>SetAccessListType tells the system to treat the AccessList as a whitelist</p>

<h4 id="func-setallowzeroin">func  SetAllowZeroIn</h4>

<pre><code class="language-go">func SetAllowZeroIn(b bool) func(*SAMEmit) error
</code></pre>

<p>SetAllowZeroIn tells the tunnel to accept zero-hop peers</p>

<h4 id="func-setallowzeroout">func  SetAllowZeroOut</h4>

<pre><code class="language-go">func SetAllowZeroOut(b bool) func(*SAMEmit) error
</code></pre>

<p>SetAllowZeroOut tells the tunnel to accept zero-hop peers</p>

<h4 id="func-setcloseidle">func  SetCloseIdle</h4>

<pre><code class="language-go">func SetCloseIdle(b bool) func(*SAMEmit) error
</code></pre>

<p>SetCloseIdle tells the connection to close it&rsquo;s tunnels during extended idle
time.</p>

<h4 id="func-setcloseidletime">func  SetCloseIdleTime</h4>

<pre><code class="language-go">func SetCloseIdleTime(u int) func(*SAMEmit) error
</code></pre>

<p>SetCloseIdleTime sets the time to wait before closing tunnels to idle levels</p>

<h4 id="func-setcloseidletimems">func  SetCloseIdleTimeMs</h4>

<pre><code class="language-go">func SetCloseIdleTimeMs(u int) func(*SAMEmit) error
</code></pre>

<p>SetCloseIdleTimeMs sets the time to wait before closing tunnels to idle levels
in milliseconds</p>

<h4 id="func-setcompress">func  SetCompress</h4>

<pre><code class="language-go">func SetCompress(b bool) func(*SAMEmit) error
</code></pre>

<p>SetCompress tells clients to use compression</p>

<h4 id="func-setencrypt">func  SetEncrypt</h4>

<pre><code class="language-go">func SetEncrypt(b bool) func(*SAMEmit) error
</code></pre>

<p>SetEncrypt tells the router to use an encrypted leaseset</p>

<h4 id="func-setfastrecieve">func  SetFastRecieve</h4>

<pre><code class="language-go">func SetFastRecieve(b bool) func(*SAMEmit) error
</code></pre>

<p>SetFastRecieve tells clients to use compression</p>

<h4 id="func-setinbackups">func  SetInBackups</h4>

<pre><code class="language-go">func SetInBackups(u int) func(*SAMEmit) error
</code></pre>

<p>SetInBackups sets the inbound tunnel backups</p>

<h4 id="func-setinlength">func  SetInLength</h4>

<pre><code class="language-go">func SetInLength(u int) func(*SAMEmit) error
</code></pre>

<p>SetInLength sets the number of hops inbound</p>

<h4 id="func-setinquantity">func  SetInQuantity</h4>

<pre><code class="language-go">func SetInQuantity(u int) func(*SAMEmit) error
</code></pre>

<p>SetInQuantity sets the inbound tunnel quantity</p>

<h4 id="func-setinvariance">func  SetInVariance</h4>

<pre><code class="language-go">func SetInVariance(i int) func(*SAMEmit) error
</code></pre>

<p>SetInVariance sets the variance of a number of hops inbound</p>

<h4 id="func-setleasesetkey">func  SetLeaseSetKey</h4>

<pre><code class="language-go">func SetLeaseSetKey(s string) func(*SAMEmit) error
</code></pre>

<p>SetLeaseSetKey sets the host of the SAMEmit&rsquo;s SAM bridge</p>

<h4 id="func-setleasesetprivatekey">func  SetLeaseSetPrivateKey</h4>

<pre><code class="language-go">func SetLeaseSetPrivateKey(s string) func(*SAMEmit) error
</code></pre>

<p>SetLeaseSetPrivateKey sets the host of the SAMEmit&rsquo;s SAM bridge</p>

<h4 id="func-setleasesetprivatesigningkey">func  SetLeaseSetPrivateSigningKey</h4>

<pre><code class="language-go">func SetLeaseSetPrivateSigningKey(s string) func(*SAMEmit) error
</code></pre>

<p>SetLeaseSetPrivateSigningKey sets the host of the SAMEmit&rsquo;s SAM bridge</p>

<h4 id="func-setmessagereliability">func  SetMessageReliability</h4>

<pre><code class="language-go">func SetMessageReliability(s string) func(*SAMEmit) error
</code></pre>

<p>SetMessageReliability sets the host of the SAMEmit&rsquo;s SAM bridge</p>

<h4 id="func-setname">func  SetName</h4>

<pre><code class="language-go">func SetName(s string) func(*SAMEmit) error
</code></pre>

<p>SetName sets the host of the SAMEmit&rsquo;s SAM bridge</p>

<h4 id="func-setoutbackups">func  SetOutBackups</h4>

<pre><code class="language-go">func SetOutBackups(u int) func(*SAMEmit) error
</code></pre>

<p>SetOutBackups sets the inbound tunnel backups</p>

<h4 id="func-setoutlength">func  SetOutLength</h4>

<pre><code class="language-go">func SetOutLength(u int) func(*SAMEmit) error
</code></pre>

<p>SetOutLength sets the number of hops outbound</p>

<h4 id="func-setoutquantity">func  SetOutQuantity</h4>

<pre><code class="language-go">func SetOutQuantity(u int) func(*SAMEmit) error
</code></pre>

<p>SetOutQuantity sets the outbound tunnel quantity</p>

<h4 id="func-setoutvariance">func  SetOutVariance</h4>

<pre><code class="language-go">func SetOutVariance(i int) func(*SAMEmit) error
</code></pre>

<p>SetOutVariance sets the variance of a number of hops outbound</p>

<h4 id="func-setreduceidle">func  SetReduceIdle</h4>

<pre><code class="language-go">func SetReduceIdle(b bool) func(*SAMEmit) error
</code></pre>

<p>SetReduceIdle tells the connection to reduce it&rsquo;s tunnels during extended idle
time.</p>

<h4 id="func-setreduceidlequantity">func  SetReduceIdleQuantity</h4>

<pre><code class="language-go">func SetReduceIdleQuantity(u int) func(*SAMEmit) error
</code></pre>

<p>SetReduceIdleQuantity sets minimum number of tunnels to reduce to during idle
time</p>

<h4 id="func-setreduceidletime">func  SetReduceIdleTime</h4>

<pre><code class="language-go">func SetReduceIdleTime(u int) func(*SAMEmit) error
</code></pre>

<p>SetReduceIdleTime sets the time to wait before reducing tunnels to idle levels</p>

<h4 id="func-setreduceidletimems">func  SetReduceIdleTimeMs</h4>

<pre><code class="language-go">func SetReduceIdleTimeMs(u int) func(*SAMEmit) error
</code></pre>

<p>SetReduceIdleTimeMs sets the time to wait before reducing tunnels to idle levels
in milliseconds</p>

<h4 id="func-setsamaddress">func  SetSAMAddress</h4>

<pre><code class="language-go">func SetSAMAddress(s string) func(*SAMEmit) error
</code></pre>

<p>SetSAMAddress sets the SAM address all-at-once</p>

<h4 id="func-setsamhost">func  SetSAMHost</h4>

<pre><code class="language-go">func SetSAMHost(s string) func(*SAMEmit) error
</code></pre>

<p>SetSAMHost sets the host of the SAMEmit&rsquo;s SAM bridge</p>

<h4 id="func-setsamport">func  SetSAMPort</h4>

<pre><code class="language-go">func SetSAMPort(s string) func(*SAMEmit) error
</code></pre>

<p>SetSAMPort sets the port of the SAMEmit&rsquo;s SAM bridge using a string</p>

<h4 id="func-settype">func  SetType</h4>

<pre><code class="language-go">func SetType(s string) func(*SAMEmit) error
</code></pre>

<p>SetType sets the type of the forwarder server</p>

<h4 id="func-splithostport">func  SplitHostPort</h4>

<pre><code class="language-go">func SplitHostPort(hostport string) (string, string, error)
</code></pre>

<h4 id="type-datagramsession">type DatagramSession</h4>

<pre><code class="language-go">type DatagramSession struct {
}
</code></pre>

<p>The DatagramSession implements net.PacketConn. It works almost like ordinary
UDP, except that datagrams may be at most 31kB large. These datagrams are also
end-to-end encrypted, signed and includes replay-protection. And they are also
built to be surveillance-resistant (yey!).</p>

<h4 id="func-datagramsession-accept">func (*DatagramSession) Accept</h4>

<pre><code class="language-go">func (s *DatagramSession) Accept() (net.Conn, error)
</code></pre>

<h4 id="func-datagramsession-addr">func (*DatagramSession) Addr</h4>

<pre><code class="language-go">func (s *DatagramSession) Addr() net.Addr
</code></pre>

<h4 id="func-datagramsession-b32">func (*DatagramSession) B32</h4>

<pre><code class="language-go">func (s *DatagramSession) B32() string
</code></pre>

<h4 id="func-datagramsession-close">func (*DatagramSession) Close</h4>

<pre><code class="language-go">func (s *DatagramSession) Close() error
</code></pre>

<p>Closes the DatagramSession. Implements net.PacketConn</p>

<h4 id="func-datagramsession-dial">func (*DatagramSession) Dial</h4>

<pre><code class="language-go">func (s *DatagramSession) Dial(net string, addr string) (*DatagramSession, error)
</code></pre>

<h4 id="func-datagramsession-diali2premote">func (*DatagramSession) DialI2PRemote</h4>

<pre><code class="language-go">func (s *DatagramSession) DialI2PRemote(net string, addr net.Addr) (*DatagramSession, error)
</code></pre>

<h4 id="func-datagramsession-dialremote">func (*DatagramSession) DialRemote</h4>

<pre><code class="language-go">func (s *DatagramSession) DialRemote(net, addr string) (net.PacketConn, error)
</code></pre>

<h4 id="func-datagramsession-localaddr">func (*DatagramSession) LocalAddr</h4>

<pre><code class="language-go">func (s *DatagramSession) LocalAddr() net.Addr
</code></pre>

<p>Implements net.PacketConn</p>

<h4 id="func-datagramsession-locali2paddr">func (*DatagramSession) LocalI2PAddr</h4>

<pre><code class="language-go">func (s *DatagramSession) LocalI2PAddr() i2pkeys.I2PAddr
</code></pre>

<p>Returns the I2P destination of the DatagramSession.</p>

<h4 id="func-datagramsession-lookup">func (*DatagramSession) Lookup</h4>

<pre><code class="language-go">func (s *DatagramSession) Lookup(name string) (a net.Addr, err error)
</code></pre>

<h4 id="func-datagramsession-read">func (*DatagramSession) Read</h4>

<pre><code class="language-go">func (s *DatagramSession) Read(b []byte) (n int, err error)
</code></pre>

<h4 id="func-datagramsession-readfrom">func (*DatagramSession) ReadFrom</h4>

<pre><code class="language-go">func (s *DatagramSession) ReadFrom(b []byte) (n int, addr net.Addr, err error)
</code></pre>

<p>Reads one datagram sent to the destination of the DatagramSession. Returns the
number of bytes read, from what address it was sent, or an error. implements
net.PacketConn</p>

<h4 id="func-datagramsession-remoteaddr">func (*DatagramSession) RemoteAddr</h4>

<pre><code class="language-go">func (s *DatagramSession) RemoteAddr() net.Addr
</code></pre>

<h4 id="func-datagramsession-setdeadline">func (*DatagramSession) SetDeadline</h4>

<pre><code class="language-go">func (s *DatagramSession) SetDeadline(t time.Time) error
</code></pre>

<p>Sets read and write deadlines for the DatagramSession. Implements net.PacketConn
and does the same thing. Setting write deadlines for datagrams is seldom done.</p>

<h4 id="func-datagramsession-setreaddeadline">func (*DatagramSession) SetReadDeadline</h4>

<pre><code class="language-go">func (s *DatagramSession) SetReadDeadline(t time.Time) error
</code></pre>

<p>Sets read deadline for the DatagramSession. Implements net.PacketConn</p>

<h4 id="func-datagramsession-setwritebuffer">func (*DatagramSession) SetWriteBuffer</h4>

<pre><code class="language-go">func (s *DatagramSession) SetWriteBuffer(bytes int) error
</code></pre>

<h4 id="func-datagramsession-setwritedeadline">func (*DatagramSession) SetWriteDeadline</h4>

<pre><code class="language-go">func (s *DatagramSession) SetWriteDeadline(t time.Time) error
</code></pre>

<p>Sets the write deadline for the DatagramSession. Implements net.Packetconn.</p>

<h4 id="func-datagramsession-write">func (*DatagramSession) Write</h4>

<pre><code class="language-go">func (s *DatagramSession) Write(b []byte) (int, error)
</code></pre>

<h4 id="func-datagramsession-writeto">func (*DatagramSession) WriteTo</h4>

<pre><code class="language-go">func (s *DatagramSession) WriteTo(b []byte, addr net.Addr) (n int, err error)
</code></pre>

<p>Sends one signed datagram to the destination specified. At the time of writing,
maximum size is 31 kilobyte, but this may change in the future. Implements
net.PacketConn.</p>

<h4 id="type-i2pconfig">type I2PConfig</h4>

<pre><code class="language-go">type I2PConfig struct {
	SamHost string
	SamPort string
	TunName string

	SamMin string
	SamMax string

	Fromport string
	Toport   string

	Style   string
	TunType string

	DestinationKeys i2pkeys.I2PKeys

	SigType                   string
	EncryptLeaseSet           string
	LeaseSetKey               string
	LeaseSetPrivateKey        string
	LeaseSetPrivateSigningKey string
	LeaseSetKeys              i2pkeys.I2PKeys
	InAllowZeroHop            string
	OutAllowZeroHop           string
	InLength                  string
	OutLength                 string
	InQuantity                string
	OutQuantity               string
	InVariance                string
	OutVariance               string
	InBackupQuantity          string
	OutBackupQuantity         string
	FastRecieve               string
	UseCompression            string
	MessageReliability        string
	CloseIdle                 string
	CloseIdleTime             string
	ReduceIdle                string
	ReduceIdleTime            string
	ReduceIdleQuantity        string
	LeaseSetEncryption        string

	//Streaming Library options
	AccessListType string
	AccessList     []string
}
</code></pre>

<p>I2PConfig is a struct which manages I2P configuration options</p>

<h4 id="func-newconfig">func  NewConfig</h4>

<pre><code class="language-go">func NewConfig(opts ...func(*I2PConfig) error) (*I2PConfig, error)
</code></pre>

<h4 id="func-i2pconfig-accesslist">func (*I2PConfig) Accesslist</h4>

<pre><code class="language-go">func (f *I2PConfig) Accesslist() string
</code></pre>

<p>Accesslist generates the I2CP access list configuration string based on the
configured access list</p>

<h4 id="func-i2pconfig-accesslisttype">func (*I2PConfig) Accesslisttype</h4>

<pre><code class="language-go">func (f *I2PConfig) Accesslisttype() string
</code></pre>

<p>Accesslisttype returns the I2CP access list configuration string based on the
AccessListType setting</p>

<h4 id="func-i2pconfig-close">func (*I2PConfig) Close</h4>

<pre><code class="language-go">func (f *I2PConfig) Close() string
</code></pre>

<p>Close returns I2CP close-on-idle configuration settings as a string if enabled</p>

<h4 id="func-i2pconfig-destinationkey">func (*I2PConfig) DestinationKey</h4>

<pre><code class="language-go">func (f *I2PConfig) DestinationKey() string
</code></pre>

<p>DestinationKey returns the DESTINATION configuration string for the SAM bridge
If destination keys are set, returns them as a string, otherwise returns
&ldquo;TRANSIENT&rdquo;</p>

<h4 id="func-i2pconfig-dozero">func (*I2PConfig) DoZero</h4>

<pre><code class="language-go">func (f *I2PConfig) DoZero() string
</code></pre>

<p>DoZero returns the zero hop and fast receive configuration string settings</p>

<h4 id="func-i2pconfig-encryptlease">func (*I2PConfig) EncryptLease</h4>

<pre><code class="language-go">func (f *I2PConfig) EncryptLease() string
</code></pre>

<p>EncryptLease returns the lease set encryption configuration string Returns
&ldquo;i2cp.encryptLeaseSet=true&rdquo; if encryption is enabled, empty string otherwise</p>

<h4 id="func-i2pconfig-fromport">func (*I2PConfig) FromPort</h4>

<pre><code class="language-go">func (f *I2PConfig) FromPort() string
</code></pre>

<p>FromPort returns the FROM_PORT configuration string for SAM bridges &gt;= 3.1
Returns an empty string if SAM version &lt; 3.1 or if fromport is &ldquo;0&rdquo;</p>

<h4 id="func-i2pconfig-id">func (*I2PConfig) ID</h4>

<pre><code class="language-go">func (f *I2PConfig) ID() string
</code></pre>

<p>ID returns the tunnel name as a formatted string. If no tunnel name is set,
generates a random 12-character name using lowercase letters.</p>

<h4 id="func-i2pconfig-leasesetencryptiontype">func (*I2PConfig) LeaseSetEncryptionType</h4>

<pre><code class="language-go">func (f *I2PConfig) LeaseSetEncryptionType() string
</code></pre>

<p>LeaseSetEncryptionType returns the I2CP lease set encryption type configuration
string. If no encryption type is set, returns default value &ldquo;4,0&rdquo;. Validates
that all encryption types are valid integers.</p>

<h4 id="func-i2pconfig-leasesetsettings">func (*I2PConfig) Leasesetsettings</h4>

<pre><code class="language-go">func (f *I2PConfig) Leasesetsettings() (string, string, string)
</code></pre>

<p>Leasesetsettings returns the lease set configuration strings for I2P Returns
three strings: lease set key, private key, and private signing key settings</p>

<h4 id="func-i2pconfig-maxsam">func (*I2PConfig) MaxSAM</h4>

<pre><code class="language-go">func (f *I2PConfig) MaxSAM() string
</code></pre>

<p>MaxSAM returns the maximum SAM version supported as a string If no maximum
version is set, returns default value &ldquo;3.1&rdquo;</p>

<h4 id="func-i2pconfig-minsam">func (*I2PConfig) MinSAM</h4>

<pre><code class="language-go">func (f *I2PConfig) MinSAM() string
</code></pre>

<p>MinSAM returns the minimum SAM version supported as a string If no minimum
version is set, returns default value &ldquo;3.0&rdquo;</p>

<h4 id="func-i2pconfig-print">func (*I2PConfig) Print</h4>

<pre><code class="language-go">func (f *I2PConfig) Print() []string
</code></pre>

<p>Print returns a slice of strings containing all the I2P configuration settings</p>

<h4 id="func-i2pconfig-reduce">func (*I2PConfig) Reduce</h4>

<pre><code class="language-go">func (f *I2PConfig) Reduce() string
</code></pre>

<p>Reduce returns I2CP reduce-on-idle configuration settings as a string if enabled</p>

<h4 id="func-i2pconfig-reliability">func (*I2PConfig) Reliability</h4>

<pre><code class="language-go">func (f *I2PConfig) Reliability() string
</code></pre>

<p>Reliability returns the message reliability configuration string for the SAM
bridge If a reliability setting is specified, returns formatted
i2cp.messageReliability setting</p>

<h4 id="func-i2pconfig-sam">func (*I2PConfig) Sam</h4>

<pre><code class="language-go">func (f *I2PConfig) Sam() string
</code></pre>

<p>Sam returns the SAM bridge address as a string in the format &ldquo;host:port&rdquo;</p>

<h4 id="func-i2pconfig-sessionstyle">func (*I2PConfig) SessionStyle</h4>

<pre><code class="language-go">func (f *I2PConfig) SessionStyle() string
</code></pre>

<p>SessionStyle returns the SAM session style configuration string If no style is
set, defaults to &ldquo;STREAM&rdquo;</p>

<h4 id="func-i2pconfig-setsamaddress">func (*I2PConfig) SetSAMAddress</h4>

<pre><code class="language-go">func (f *I2PConfig) SetSAMAddress(addr string)
</code></pre>

<p>SetSAMAddress sets the SAM bridge host and port from a combined address string
addr format can be either &ldquo;host&rdquo; or &ldquo;host:port&rdquo;</p>

<h4 id="func-i2pconfig-signaturetype">func (*I2PConfig) SignatureType</h4>

<pre><code class="language-go">func (f *I2PConfig) SignatureType() string
</code></pre>

<p>SignatureType returns the SIGNATURE_TYPE configuration string for SAM bridges &gt;=
3.1 Returns empty string if SAM version &lt; 3.1 or if no signature type is set</p>

<h4 id="func-i2pconfig-toport">func (*I2PConfig) ToPort</h4>

<pre><code class="language-go">func (f *I2PConfig) ToPort() string
</code></pre>

<p>ToPort returns the TO_PORT configuration string for SAM bridges &gt;= 3.1 Returns
an empty string if SAM version &lt; 3.1 or if toport is &ldquo;0&rdquo;</p>

<h4 id="type-option">type Option</h4>

<pre><code class="language-go">type Option func(*SAMEmit) error
</code></pre>

<p>Option is a SAMEmit Option</p>

<h4 id="type-options">type Options</h4>

<pre><code class="language-go">type Options map[string]string
</code></pre>

<p>options map</p>

<h4 id="func-options-aslist">func (Options) AsList</h4>

<pre><code class="language-go">func (opts Options) AsList() (ls []string)
</code></pre>

<p>obtain sam options as list of strings</p>

<h4 id="type-primarysession">type PrimarySession</h4>

<pre><code class="language-go">type PrimarySession struct {
	Timeout  time.Duration
	Deadline time.Time

	Config SAMEmit
}
</code></pre>

<p>Represents a primary session.</p>

<h4 id="func-primarysession-addr">func (*PrimarySession) Addr</h4>

<pre><code class="language-go">func (ss *PrimarySession) Addr() i2pkeys.I2PAddr
</code></pre>

<p>Returns the I2P destination (the address) of the stream session</p>

<h4 id="func-primarysession-close">func (*PrimarySession) Close</h4>

<pre><code class="language-go">func (ss *PrimarySession) Close() error
</code></pre>

<h4 id="func-primarysession-dial">func (*PrimarySession) Dial</h4>

<pre><code class="language-go">func (sam *PrimarySession) Dial(network, addr string) (net.Conn, error)
</code></pre>

<h4 id="func-primarysession-dialtcp">func (*PrimarySession) DialTCP</h4>

<pre><code class="language-go">func (sam *PrimarySession) DialTCP(network string, laddr, raddr net.Addr) (net.Conn, error)
</code></pre>

<p>DialTCP implements x/dialer</p>

<h4 id="func-primarysession-dialtcpi2p">func (*PrimarySession) DialTCPI2P</h4>

<pre><code class="language-go">func (sam *PrimarySession) DialTCPI2P(network string, laddr, raddr string) (net.Conn, error)
</code></pre>

<h4 id="func-primarysession-dialudp">func (*PrimarySession) DialUDP</h4>

<pre><code class="language-go">func (sam *PrimarySession) DialUDP(network string, laddr, raddr net.Addr) (net.PacketConn, error)
</code></pre>

<p>DialUDP implements x/dialer</p>

<h4 id="func-primarysession-dialudpi2p">func (*PrimarySession) DialUDPI2P</h4>

<pre><code class="language-go">func (sam *PrimarySession) DialUDPI2P(network, laddr, raddr string) (*DatagramSession, error)
</code></pre>

<h4 id="func-primarysession-from">func (*PrimarySession) From</h4>

<pre><code class="language-go">func (ss *PrimarySession) From() string
</code></pre>

<h4 id="func-primarysession-id">func (*PrimarySession) ID</h4>

<pre><code class="language-go">func (ss *PrimarySession) ID() string
</code></pre>

<p>Returns the local tunnel name of the I2P tunnel used for the stream session</p>

<h4 id="func-primarysession-keys">func (*PrimarySession) Keys</h4>

<pre><code class="language-go">func (ss *PrimarySession) Keys() i2pkeys.I2PKeys
</code></pre>

<p>Returns the keys associated with the stream session</p>

<h4 id="func-primarysession-localaddr">func (*PrimarySession) LocalAddr</h4>

<pre><code class="language-go">func (ss *PrimarySession) LocalAddr() net.Addr
</code></pre>

<h4 id="func-primarysession-lookup">func (*PrimarySession) Lookup</h4>

<pre><code class="language-go">func (s *PrimarySession) Lookup(name string) (a net.Addr, err error)
</code></pre>

<h4 id="func-primarysession-newdatagramsubsession">func (*PrimarySession) NewDatagramSubSession</h4>

<pre><code class="language-go">func (s *PrimarySession) NewDatagramSubSession(id string, udpPort int) (*DatagramSession, error)
</code></pre>

<p>Creates a new datagram session. udpPort is the UDP port SAM is listening on, and
if you set it to zero, it will use SAMs standard UDP port.</p>

<h4 id="func-primarysession-newrawsubsession">func (*PrimarySession) NewRawSubSession</h4>

<pre><code class="language-go">func (s *PrimarySession) NewRawSubSession(id string, udpPort int) (*RawSession, error)
</code></pre>

<p>Creates a new raw session. udpPort is the UDP port SAM is listening on, and if
you set it to zero, it will use SAMs standard UDP port.</p>

<h4 id="func-primarysession-newstreamsubsession">func (*PrimarySession) NewStreamSubSession</h4>

<pre><code class="language-go">func (sam *PrimarySession) NewStreamSubSession(id string) (*StreamSession, error)
</code></pre>

<p>Creates a new StreamSession with the I2CP- and streaminglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-primarysession-newuniquestreamsubsession">func (*PrimarySession) NewUniqueStreamSubSession</h4>

<pre><code class="language-go">func (sam *PrimarySession) NewUniqueStreamSubSession(id string) (*StreamSession, error)
</code></pre>

<p>Creates a new StreamSession with the I2CP- and streaminglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-primarysession-resolve">func (*PrimarySession) Resolve</h4>

<pre><code class="language-go">func (sam *PrimarySession) Resolve(network, addr string) (net.Addr, error)
</code></pre>

<h4 id="func-primarysession-resolvetcpaddr">func (*PrimarySession) ResolveTCPAddr</h4>

<pre><code class="language-go">func (sam *PrimarySession) ResolveTCPAddr(network, dest string) (net.Addr, error)
</code></pre>

<h4 id="func-primarysession-resolveudpaddr">func (*PrimarySession) ResolveUDPAddr</h4>

<pre><code class="language-go">func (sam *PrimarySession) ResolveUDPAddr(network, dest string) (net.Addr, error)
</code></pre>

<h4 id="func-primarysession-signaturetype">func (*PrimarySession) SignatureType</h4>

<pre><code class="language-go">func (ss *PrimarySession) SignatureType() string
</code></pre>

<h4 id="func-primarysession-to">func (*PrimarySession) To</h4>

<pre><code class="language-go">func (ss *PrimarySession) To() string
</code></pre>

<h4 id="type-rawsession">type RawSession</h4>

<pre><code class="language-go">type RawSession struct {
}
</code></pre>

<p>The RawSession provides no authentication of senders, and there is no sender
address attached to datagrams, so all communication is anonymous. The messages
send are however still endpoint-to-endpoint encrypted. You need to figure out a
way to identify and authenticate clients yourself, iff that is needed. Raw
datagrams may be at most 32 kB in size. There is no overhead of authentication,
which is the reason to use this..</p>

<h4 id="func-rawsession-close">func (*RawSession) Close</h4>

<pre><code class="language-go">func (s *RawSession) Close() error
</code></pre>

<p>Closes the RawSession.</p>

<h4 id="func-rawsession-localaddr">func (*RawSession) LocalAddr</h4>

<pre><code class="language-go">func (s *RawSession) LocalAddr() i2pkeys.I2PAddr
</code></pre>

<p>Returns the local I2P destination of the RawSession.</p>

<h4 id="func-rawsession-read">func (*RawSession) Read</h4>

<pre><code class="language-go">func (s *RawSession) Read(b []byte) (n int, err error)
</code></pre>

<p>Reads one raw datagram sent to the destination of the DatagramSession. Returns
the number of bytes read. Who sent the raw message can not be determined at this
layer - you need to do it (in a secure way!).</p>

<h4 id="func-rawsession-setdeadline">func (*RawSession) SetDeadline</h4>

<pre><code class="language-go">func (s *RawSession) SetDeadline(t time.Time) error
</code></pre>

<h4 id="func-rawsession-setreaddeadline">func (*RawSession) SetReadDeadline</h4>

<pre><code class="language-go">func (s *RawSession) SetReadDeadline(t time.Time) error
</code></pre>

<h4 id="func-rawsession-setwritedeadline">func (*RawSession) SetWriteDeadline</h4>

<pre><code class="language-go">func (s *RawSession) SetWriteDeadline(t time.Time) error
</code></pre>

<h4 id="func-rawsession-writeto">func (*RawSession) WriteTo</h4>

<pre><code class="language-go">func (s *RawSession) WriteTo(b []byte, addr i2pkeys.I2PAddr) (n int, err error)
</code></pre>

<p>Sends one raw datagram to the destination specified. At the time of writing,
maximum size is 32 kilobyte, but this may change in the future.</p>

<h4 id="type-sam">type SAM</h4>

<pre><code class="language-go">type SAM struct {
	Config SAMEmit
}
</code></pre>

<p>Used for controlling I2Ps SAMv3.</p>

<h4 id="func-newsam">func  NewSAM</h4>

<pre><code class="language-go">func NewSAM(address string) (*SAM, error)
</code></pre>

<p>Creates a new controller for the I2P routers SAM bridge.</p>

<h4 id="func-sam-close">func (*SAM) Close</h4>

<pre><code class="language-go">func (sam *SAM) Close() error
</code></pre>

<p>close this sam session</p>

<h4 id="func-sam-ensurekeyfile">func (*SAM) EnsureKeyfile</h4>

<pre><code class="language-go">func (sam *SAM) EnsureKeyfile(fname string) (keys i2pkeys.I2PKeys, err error)
</code></pre>

<p>if keyfile fname does not exist</p>

<h4 id="func-sam-keys">func (*SAM) Keys</h4>

<pre><code class="language-go">func (sam *SAM) Keys() (k *i2pkeys.I2PKeys)
</code></pre>

<h4 id="func-sam-lookup">func (*SAM) Lookup</h4>

<pre><code class="language-go">func (sam *SAM) Lookup(name string) (i2pkeys.I2PAddr, error)
</code></pre>

<p>Performs a lookup, probably this order: 1) routers known addresses, cached
addresses, 3) by asking peers in the I2P network.</p>

<h4 id="func-sam-newdatagramsession">func (*SAM) NewDatagramSession</h4>

<pre><code class="language-go">func (s *SAM) NewDatagramSession(id string, keys i2pkeys.I2PKeys, options []string, udpPort int) (*DatagramSession, error)
</code></pre>

<p>Creates a new datagram session. udpPort is the UDP port SAM is listening on, and
if you set it to zero, it will use SAMs standard UDP port.</p>

<h4 id="func-sam-newkeys">func (*SAM) NewKeys</h4>

<pre><code class="language-go">func (sam *SAM) NewKeys(sigType ...string) (i2pkeys.I2PKeys, error)
</code></pre>

<p>Creates the I2P-equivalent of an IP address, that is unique and only the one who
has the private keys can send messages from. The public keys are the I2P
desination (the address) that anyone can send messages to.</p>

<h4 id="func-sam-newprimarysession">func (*SAM) NewPrimarySession</h4>

<pre><code class="language-go">func (sam *SAM) NewPrimarySession(id string, keys i2pkeys.I2PKeys, options []string) (*PrimarySession, error)
</code></pre>

<p>Creates a new PrimarySession with the I2CP- and streaminglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-sam-newprimarysessionwithsignature">func (*SAM) NewPrimarySessionWithSignature</h4>

<pre><code class="language-go">func (sam *SAM) NewPrimarySessionWithSignature(id string, keys i2pkeys.I2PKeys, options []string, sigType string) (*PrimarySession, error)
</code></pre>

<p>Creates a new PrimarySession with the I2CP- and PRIMARYinglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-sam-newrawsession">func (*SAM) NewRawSession</h4>

<pre><code class="language-go">func (s *SAM) NewRawSession(id string, keys i2pkeys.I2PKeys, options []string, udpPort int) (*RawSession, error)
</code></pre>

<p>Creates a new raw session. udpPort is the UDP port SAM is listening on, and if
you set it to zero, it will use SAMs standard UDP port.</p>

<h4 id="func-sam-newstreamsession">func (*SAM) NewStreamSession</h4>

<pre><code class="language-go">func (sam *SAM) NewStreamSession(id string, keys i2pkeys.I2PKeys, options []string) (*StreamSession, error)
</code></pre>

<p>Creates a new StreamSession with the I2CP- and streaminglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-sam-newstreamsessionwithsignature">func (*SAM) NewStreamSessionWithSignature</h4>

<pre><code class="language-go">func (sam *SAM) NewStreamSessionWithSignature(id string, keys i2pkeys.I2PKeys, options []string, sigType string) (*StreamSession, error)
</code></pre>

<p>Creates a new StreamSession with the I2CP- and streaminglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-sam-newstreamsessionwithsignatureandports">func (*SAM) NewStreamSessionWithSignatureAndPorts</h4>

<pre><code class="language-go">func (sam *SAM) NewStreamSessionWithSignatureAndPorts(id, from, to string, keys i2pkeys.I2PKeys, options []string, sigType string) (*StreamSession, error)
</code></pre>

<p>Creates a new StreamSession with the I2CP- and streaminglib options as
specified. See the I2P documentation for a full list of options.</p>

<h4 id="func-sam-readkeys">func (*SAM) ReadKeys</h4>

<pre><code class="language-go">func (sam *SAM) ReadKeys(r io.Reader) (err error)
</code></pre>

<p>read public/private keys from an io.Reader</p>

<h4 id="type-samconn">type SAMConn</h4>

<pre><code class="language-go">type SAMConn struct {
}
</code></pre>

<p>Implements net.Conn</p>

<h4 id="func-samconn-close">func (*SAMConn) Close</h4>

<pre><code class="language-go">func (sc *SAMConn) Close() error
</code></pre>

<p>Implements net.Conn</p>

<h4 id="func-samconn-localaddr">func (*SAMConn) LocalAddr</h4>

<pre><code class="language-go">func (sc *SAMConn) LocalAddr() net.Addr
</code></pre>

<h4 id="func-samconn-read">func (*SAMConn) Read</h4>

<pre><code class="language-go">func (sc *SAMConn) Read(buf []byte) (int, error)
</code></pre>

<p>Implements net.Conn</p>

<h4 id="func-samconn-remoteaddr">func (*SAMConn) RemoteAddr</h4>

<pre><code class="language-go">func (sc *SAMConn) RemoteAddr() net.Addr
</code></pre>

<h4 id="func-samconn-setdeadline">func (*SAMConn) SetDeadline</h4>

<pre><code class="language-go">func (sc *SAMConn) SetDeadline(t time.Time) error
</code></pre>

<p>Implements net.Conn</p>

<h4 id="func-samconn-setreaddeadline">func (*SAMConn) SetReadDeadline</h4>

<pre><code class="language-go">func (sc *SAMConn) SetReadDeadline(t time.Time) error
</code></pre>

<p>Implements net.Conn</p>

<h4 id="func-samconn-setwritedeadline">func (*SAMConn) SetWriteDeadline</h4>

<pre><code class="language-go">func (sc *SAMConn) SetWriteDeadline(t time.Time) error
</code></pre>

<p>Implements net.Conn</p>

<h4 id="func-samconn-write">func (*SAMConn) Write</h4>

<pre><code class="language-go">func (sc *SAMConn) Write(buf []byte) (int, error)
</code></pre>

<p>Implements net.Conn</p>

<h4 id="type-samemit">type SAMEmit</h4>

<pre><code class="language-go">type SAMEmit struct {
	I2PConfig
}
</code></pre>

<h4 id="func-newemit">func  NewEmit</h4>

<pre><code class="language-go">func NewEmit(opts ...func(*SAMEmit) error) (*SAMEmit, error)
</code></pre>

<h4 id="func-samemit-accept">func (*SAMEmit) Accept</h4>

<pre><code class="language-go">func (e *SAMEmit) Accept() string
</code></pre>

<h4 id="func-samemit-acceptbytes">func (*SAMEmit) AcceptBytes</h4>

<pre><code class="language-go">func (e *SAMEmit) AcceptBytes() []byte
</code></pre>

<h4 id="func-samemit-connect">func (*SAMEmit) Connect</h4>

<pre><code class="language-go">func (e *SAMEmit) Connect(dest string) string
</code></pre>

<h4 id="func-samemit-connectbytes">func (*SAMEmit) ConnectBytes</h4>

<pre><code class="language-go">func (e *SAMEmit) ConnectBytes(dest string) []byte
</code></pre>

<h4 id="func-samemit-create">func (*SAMEmit) Create</h4>

<pre><code class="language-go">func (e *SAMEmit) Create() string
</code></pre>

<h4 id="func-samemit-createbytes">func (*SAMEmit) CreateBytes</h4>

<pre><code class="language-go">func (e *SAMEmit) CreateBytes() []byte
</code></pre>

<h4 id="func-samemit-generatedestination">func (*SAMEmit) GenerateDestination</h4>

<pre><code class="language-go">func (e *SAMEmit) GenerateDestination() string
</code></pre>

<h4 id="func-samemit-generatedestinationbytes">func (*SAMEmit) GenerateDestinationBytes</h4>

<pre><code class="language-go">func (e *SAMEmit) GenerateDestinationBytes() []byte
</code></pre>

<h4 id="func-samemit-hello">func (*SAMEmit) Hello</h4>

<pre><code class="language-go">func (e *SAMEmit) Hello() string
</code></pre>

<h4 id="func-samemit-hellobytes">func (*SAMEmit) HelloBytes</h4>

<pre><code class="language-go">func (e *SAMEmit) HelloBytes() []byte
</code></pre>

<h4 id="func-samemit-lookup">func (*SAMEmit) Lookup</h4>

<pre><code class="language-go">func (e *SAMEmit) Lookup(name string) string
</code></pre>

<h4 id="func-samemit-lookupbytes">func (*SAMEmit) LookupBytes</h4>

<pre><code class="language-go">func (e *SAMEmit) LookupBytes(name string) []byte
</code></pre>

<h4 id="func-samemit-samoptionsstring">func (*SAMEmit) SamOptionsString</h4>

<pre><code class="language-go">func (e *SAMEmit) SamOptionsString() string
</code></pre>

<h4 id="type-samresolver">type SAMResolver</h4>

<pre><code class="language-go">type SAMResolver struct {
	*SAM
}
</code></pre>

<h4 id="func-newfullsamresolver">func  NewFullSAMResolver</h4>

<pre><code class="language-go">func NewFullSAMResolver(address string) (*SAMResolver, error)
</code></pre>

<h4 id="func-newsamresolver">func  NewSAMResolver</h4>

<pre><code class="language-go">func NewSAMResolver(parent *SAM) (*SAMResolver, error)
</code></pre>

<h4 id="func-samresolver-resolve">func (*SAMResolver) Resolve</h4>

<pre><code class="language-go">func (sam *SAMResolver) Resolve(name string) (i2pkeys.I2PAddr, error)
</code></pre>

<p>Performs a lookup, probably this order: 1) routers known addresses, cached
addresses, 3) by asking peers in the I2P network.</p>

<h4 id="type-streamlistener">type StreamListener</h4>

<pre><code class="language-go">type StreamListener struct {
}
</code></pre>

<h4 id="func-streamlistener-accept">func (*StreamListener) Accept</h4>

<pre><code class="language-go">func (l *StreamListener) Accept() (net.Conn, error)
</code></pre>

<p>implements net.Listener</p>

<h4 id="func-streamlistener-accepti2p">func (*StreamListener) AcceptI2P</h4>

<pre><code class="language-go">func (l *StreamListener) AcceptI2P() (*SAMConn, error)
</code></pre>

<p>accept a new inbound connection</p>

<h4 id="func-streamlistener-addr">func (*StreamListener) Addr</h4>

<pre><code class="language-go">func (l *StreamListener) Addr() net.Addr
</code></pre>

<p>get our address implements net.Listener</p>

<h4 id="func-streamlistener-close">func (*StreamListener) Close</h4>

<pre><code class="language-go">func (l *StreamListener) Close() error
</code></pre>

<p>implements net.Listener</p>

<h4 id="func-streamlistener-from">func (*StreamListener) From</h4>

<pre><code class="language-go">func (l *StreamListener) From() string
</code></pre>

<h4 id="func-streamlistener-to">func (*StreamListener) To</h4>

<pre><code class="language-go">func (l *StreamListener) To() string
</code></pre>

<h4 id="type-streamsession">type StreamSession</h4>

<pre><code class="language-go">type StreamSession struct {
	Timeout  time.Duration
	Deadline time.Time
}
</code></pre>

<p>Represents a streaming session.</p>

<h4 id="func-streamsession-addr">func (*StreamSession) Addr</h4>

<pre><code class="language-go">func (s *StreamSession) Addr() i2pkeys.I2PAddr
</code></pre>

<p>Returns the I2P destination (the address) of the stream session</p>

<h4 id="func-streamsession-close">func (*StreamSession) Close</h4>

<pre><code class="language-go">func (s *StreamSession) Close() error
</code></pre>

<h4 id="func-streamsession-dial">func (*StreamSession) Dial</h4>

<pre><code class="language-go">func (s *StreamSession) Dial(n, addr string) (c net.Conn, err error)
</code></pre>

<p>implement net.Dialer</p>

<h4 id="func-streamsession-dialcontext">func (*StreamSession) DialContext</h4>

<pre><code class="language-go">func (s *StreamSession) DialContext(ctx context.Context, n, addr string) (net.Conn, error)
</code></pre>

<p>context-aware dialer, eventually&hellip;</p>

<h4 id="func-streamsession-dialcontexti2p">func (*StreamSession) DialContextI2P</h4>

<pre><code class="language-go">func (s *StreamSession) DialContextI2P(ctx context.Context, n, addr string) (*SAMConn, error)
</code></pre>

<p>context-aware dialer, eventually&hellip;</p>

<h4 id="func-streamsession-diali2p">func (*StreamSession) DialI2P</h4>

<pre><code class="language-go">func (s *StreamSession) DialI2P(addr i2pkeys.I2PAddr) (*SAMConn, error)
</code></pre>

<p>Dials to an I2P destination and returns a SAMConn, which implements a net.Conn.</p>

<h4 id="func-streamsession-from">func (*StreamSession) From</h4>

<pre><code class="language-go">func (s *StreamSession) From() string
</code></pre>

<h4 id="func-streamsession-id">func (*StreamSession) ID</h4>

<pre><code class="language-go">func (s *StreamSession) ID() string
</code></pre>

<p>Returns the local tunnel name of the I2P tunnel used for the stream session</p>

<h4 id="func-streamsession-keys">func (*StreamSession) Keys</h4>

<pre><code class="language-go">func (s *StreamSession) Keys() i2pkeys.I2PKeys
</code></pre>

<p>Returns the keys associated with the stream session</p>

<h4 id="func-streamsession-listen">func (*StreamSession) Listen</h4>

<pre><code class="language-go">func (s *StreamSession) Listen() (*StreamListener, error)
</code></pre>

<p>create a new stream listener to accept inbound connections</p>

<h4 id="func-streamsession-localaddr">func (*StreamSession) LocalAddr</h4>

<pre><code class="language-go">func (s *StreamSession) LocalAddr() net.Addr
</code></pre>

<h4 id="func-streamsession-lookup">func (*StreamSession) Lookup</h4>

<pre><code class="language-go">func (s *StreamSession) Lookup(name string) (i2pkeys.I2PAddr, error)
</code></pre>

<p>lookup name, convenience function</p>

<h4 id="func-streamsession-read">func (*StreamSession) Read</h4>

<pre><code class="language-go">func (s *StreamSession) Read(buf []byte) (int, error)
</code></pre>

<p>Read reads data from the stream.</p>

<h4 id="func-streamsession-setdeadline">func (*StreamSession) SetDeadline</h4>

<pre><code class="language-go">func (s *StreamSession) SetDeadline(t time.Time) error
</code></pre>

<h4 id="func-streamsession-setreaddeadline">func (*StreamSession) SetReadDeadline</h4>

<pre><code class="language-go">func (s *StreamSession) SetReadDeadline(t time.Time) error
</code></pre>

<h4 id="func-streamsession-setwritedeadline">func (*StreamSession) SetWriteDeadline</h4>

<pre><code class="language-go">func (s *StreamSession) SetWriteDeadline(t time.Time) error
</code></pre>

<h4 id="func-streamsession-signaturetype">func (*StreamSession) SignatureType</h4>

<pre><code class="language-go">func (s *StreamSession) SignatureType() string
</code></pre>

<h4 id="func-streamsession-to">func (*StreamSession) To</h4>

<pre><code class="language-go">func (s *StreamSession) To() string
</code></pre>

<h4 id="func-streamsession-write">func (*StreamSession) Write</h4>

<pre><code class="language-go">func (s *StreamSession) Write(data []byte) (int, error)
</code></pre>

<p>Write sends data over the stream.</p>

      </div>
    </main>
    
    <footer class="page-footer">
      <p>Generated on 2025-10-19 01:05:21 ‚Ä¢ <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a></p>
    </footer>
  </div>
</body>
</html>