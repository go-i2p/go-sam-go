<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>primary - go-i2p/go-sam-go</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <nav class="nav-sidebar">
    <div class="repo-info">
      <h2>
        <a href="../index.html">go-i2p/go-sam-go</a>
      </h2>
      <div class="repo-meta">
        üìù 225 commits
        
      </div>
    </div>
    
    <ul class="nav-links">
      <li><a href="../index.html">Repository Overview</a></li>
      
      
        <div class="nav-section-title">Documentation:</div>
        
          <li><a href="../docs/SAMv3.html" >SAM V3</a></li>
        
          <li><a href="../docs/common/DOC.html" >common</a></li>
        
          <li><a href="../docs/datagram/DOC.html" >datagram</a></li>
        
          <li><a href="../docs/datagram2/DOC.html" >datagram2</a></li>
        
          <li><a href="../docs/datagram3/DOC.html" >datagram3</a></li>
        
          <li><a href="../docs/primary/DOC.html" class="active">primary</a></li>
        
          <li><a href="../docs/raw/DOC.html" >raw</a></li>
        
          <li><a href="../docs/DOC.html" >sam3</a></li>
        
          <li><a href="../docs/sigs.html" >sam3</a></li>
        
          <li><a href="../docs/stream/DOC.html" >stream</a></li>
        
      
    </ul>
    
    <div class="nav-footer">
      <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a>
    </div>
  </nav>
  
  <div class="main-content">
    <header class="page-header">
      <h1>primary - go-i2p/go-sam-go</h1>
    </header>
    
    <main>
      <div class="doc-content">
        <h1 id="primary">primary</h1>

<p>&ndash;</p>

<pre><code>import &quot;github.com/go-i2p/go-sam-go/primary&quot;
</code></pre>

<p>Package primary provides PRIMARY session management for sharing I2P tunnels
across multiple subsessions.</p>

<p>PRIMARY sessions allow multiple subsessions (stream, datagram, datagram2,
datagram3, raw) to share a single set of I2P tunnels, reducing resource usage
and tunnel setup overhead. Each subsession operates independently while using
the master session&rsquo;s tunnels.</p>

<p>Key features:</p>

<pre><code>- Single tunnel setup for multiple subsessions
- Mixed subsession types (stream, datagram, raw)
- Independent subsession lifecycle management
- Reduced resource usage and setup time
- SAMv3.3 PRIMARY protocol compliance
</code></pre>

<p>Primary session creation requires 2-5 minutes for I2P tunnel establishment.
Subsessions attach quickly since tunnels are already established. Use generous
timeouts for initial PRIMARY session creation.</p>

<p>Basic usage:</p>

<pre><code>sam, err := common.NewSAM(&quot;127.0.0.1:7656&quot;)
primary, err := primary.NewPrimarySession(sam, &quot;master&quot;, keys, []string{&quot;inbound.length=1&quot;})
defer primary.Close()
streamSub, err := primary.NewStreamSubsession(&quot;stream-1&quot;)
datagramSub, err := primary.NewDatagramSubsession(&quot;dgram-1&quot;)
</code></pre>

<p>See also: Package stream, datagram, datagram2, datagram3, raw for individual
session types.</p>

<h2 id="usage">Usage</h2>

<h4 id="type-datagram3subsession">type Datagram3SubSession</h4>

<pre><code class="language-go">type Datagram3SubSession struct {
	*datagram3.Datagram3Session
}
</code></pre>

<p>Datagram3SubSession wraps a datagram3.Datagram3Session to implement the
SubSession interface. This adapter allows Datagram3Session instances to be
managed by primary sessions while maintaining their full functionality and
thread-safe operations.</p>

<p>‚ö†Ô∏è SECURITY WARNING: DATAGRAM3 sources are NOT authenticated and can be spoofed!
‚ö†Ô∏è This sub-session type uses hash-based source identification which is
unauthenticated. ‚ö†Ô∏è Do not trust source addresses without additional
application-level authentication. ‚ö†Ô∏è If you need authenticated sources, use
DatagramSubSession (DATAGRAM) instead.</p>

<h4 id="func-newdatagram3subsession">func  NewDatagram3SubSession</h4>

<pre><code class="language-go">func NewDatagram3SubSession(id string, session *datagram3.Datagram3Session) *Datagram3SubSession
</code></pre>

<p>NewDatagram3SubSession creates a Datagram3SubSession wrapper around a
Datagram3Session. This constructor initializes the wrapper with proper
identification and state management to enable primary session integration.</p>

<p>‚ö†Ô∏è SECURITY WARNING: Sources are UNAUTHENTICATED and can be spoofed!</p>

<h4 id="func-datagram3subsession-active">func (*Datagram3SubSession) Active</h4>

<pre><code class="language-go">func (s *Datagram3SubSession) Active() bool
</code></pre>

<p>Active returns whether this datagram3 sub-session is currently active.</p>

<h4 id="func-datagram3subsession-close">func (*Datagram3SubSession) Close</h4>

<pre><code class="language-go">func (s *Datagram3SubSession) Close() error
</code></pre>

<p>Close closes the datagram3 sub-session and marks it as inactive.</p>

<h4 id="func-datagram3subsession-id">func (*Datagram3SubSession) ID</h4>

<pre><code class="language-go">func (s *Datagram3SubSession) ID() string
</code></pre>

<p>ID returns the unique identifier for this datagram3 sub-session.</p>

<h4 id="func-datagram3subsession-type">func (*Datagram3SubSession) Type</h4>

<pre><code class="language-go">func (s *Datagram3SubSession) Type() string
</code></pre>

<p>Type returns the session type identifier for datagram3 sessions. Returns
&ldquo;DATAGRAM3&rdquo; to distinguish from authenticated DATAGRAM sessions.</p>

<h4 id="type-datagramsubsession">type DatagramSubSession</h4>

<pre><code class="language-go">type DatagramSubSession struct {
	*datagram.DatagramSession
}
</code></pre>

<p>DatagramSubSession wraps a datagram.DatagramSession to implement the SubSession
interface. This adapter allows DatagramSession instances to be managed by
primary sessions while maintaining their full functionality and thread-safe
operations.</p>

<h4 id="func-newdatagramsubsession">func  NewDatagramSubSession</h4>

<pre><code class="language-go">func NewDatagramSubSession(id string, session *datagram.DatagramSession) *DatagramSubSession
</code></pre>

<p>NewDatagramSubSession creates a DatagramSubSession wrapper around a
DatagramSession. This constructor initializes the wrapper with proper
identification and state management to enable primary session integration.</p>

<h4 id="func-datagramsubsession-active">func (*DatagramSubSession) Active</h4>

<pre><code class="language-go">func (s *DatagramSubSession) Active() bool
</code></pre>

<p>Active returns whether this datagram sub-session is currently active.</p>

<h4 id="func-datagramsubsession-close">func (*DatagramSubSession) Close</h4>

<pre><code class="language-go">func (s *DatagramSubSession) Close() error
</code></pre>

<p>Close closes the datagram sub-session and marks it as inactive.</p>

<h4 id="func-datagramsubsession-id">func (*DatagramSubSession) ID</h4>

<pre><code class="language-go">func (s *DatagramSubSession) ID() string
</code></pre>

<p>ID returns the unique identifier for this datagram sub-session.</p>

<h4 id="func-datagramsubsession-type">func (*DatagramSubSession) Type</h4>

<pre><code class="language-go">func (s *DatagramSubSession) Type() string
</code></pre>

<p>Type returns the session type identifier for datagram sessions.</p>

<h4 id="type-primarysession">type PrimarySession</h4>

<pre><code class="language-go">type PrimarySession struct {
	*common.BaseSession
}
</code></pre>

<p>PrimarySession manages multiple sub-sessions sharing the same I2P identity and
tunnels.</p>

<h4 id="func-newprimarysession">func  NewPrimarySession</h4>

<pre><code class="language-go">func NewPrimarySession(sam *common.SAM, id string, keys i2pkeys.I2PKeys, options []string) (*PrimarySession, error)
</code></pre>

<p>NewPrimarySession creates a new primary session for managing multiple
sub-sessions. It initializes the session with the provided SAM connection,
session ID, cryptographic keys, and configuration options. The primary session
allows creating multiple sub-sessions of different types (stream, datagram, raw)
while sharing the same I2P identity and tunnels. Example usage: session, err :=
NewPrimarySession(sam, &ldquo;my-primary&rdquo;, keys, []string{&ldquo;inbound.length=2&rdquo;})</p>

<h4 id="func-newprimarysessionwithsignature">func  NewPrimarySessionWithSignature</h4>

<pre><code class="language-go">func NewPrimarySessionWithSignature(sam *common.SAM, id string, keys i2pkeys.I2PKeys, options []string, sigType string) (*PrimarySession, error)
</code></pre>

<p>NewPrimarySessionWithSignature creates a new primary session with the specified
signature type. This method allows specifying custom cryptographic parameters
for enhanced security or compatibility with specific I2P network configurations.
Example usage: session, err := NewPrimarySessionWithSignature(sam,
&ldquo;secure-primary&rdquo;, keys, options, &ldquo;EdDSA_SHA512_Ed25519&rdquo;)</p>

<h4 id="func-primarysession-addr">func (*PrimarySession) Addr</h4>

<pre><code class="language-go">func (p *PrimarySession) Addr() i2pkeys.I2PAddr
</code></pre>

<p>Addr returns the I2P address of this primary session. This address represents
the session&rsquo;s identity on the I2P network and is shared by all sub-sessions
created from this primary session. The address is derived from the primary
session&rsquo;s cryptographic keys and remains constant.</p>

<p>Example usage:</p>

<pre><code>addr := primary.Addr()
fmt.Printf(&quot;Primary session address: %s&quot;, addr.Base32())
</code></pre>

<h4 id="func-primarysession-close">func (*PrimarySession) Close</h4>

<pre><code class="language-go">func (p *PrimarySession) Close() error
</code></pre>

<p>Close closes the primary session and all associated sub-sessions. This method
performs a complete cleanup cascade, ensuring that all resources are properly
released and all sub-sessions are terminated before closing the primary session
itself. It&rsquo;s safe to call multiple times.</p>

<p>The method first closes all registered sub-sessions, then closes the primary
session&rsquo;s registry and base session. This prevents resource leaks and ensures
proper cleanup of the entire session hierarchy.</p>

<p>Example usage:</p>

<pre><code>defer primary.Close()
</code></pre>

<h4 id="func-primarysession-closesubsession">func (*PrimarySession) CloseSubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) CloseSubSession(id string) error
</code></pre>

<p>CloseSubSession closes and unregisters a specific sub-session by its ID. This
method provides selective termination of sub-sessions without affecting the
primary session or other sub-sessions. The sub-session is properly cleaned up
and removed from the registry after closure.</p>

<p>Example usage:</p>

<pre><code>err := primary.CloseSubSession(&quot;stream-1&quot;)
if err != nil {
    log.Printf(&quot;Failed to close sub-session: %v&quot;, err)
}
</code></pre>

<h4 id="func-primarysession-getsubsession">func (*PrimarySession) GetSubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) GetSubSession(id string) (SubSession, error)
</code></pre>

<p>GetSubSession retrieves a sub-session by its unique identifier. Returns the
sub-session instance if found, or an error if the sub-session does not exist or
the primary session is closed. This method provides safe access to registered
sub-sessions for management and operation.</p>

<p>Example usage:</p>

<pre><code>subSession, err := primary.GetSubSession(&quot;stream-1&quot;)
if streamSub, ok := subSession.(*StreamSubSession); ok {
    conn, err := streamSub.Dial(&quot;destination.b32.i2p&quot;)
}
</code></pre>

<h4 id="func-primarysession-listsubsessions">func (*PrimarySession) ListSubSessions</h4>

<pre><code class="language-go">func (p *PrimarySession) ListSubSessions() []SubSession
</code></pre>

<p>ListSubSessions returns a list of all currently active sub-sessions. This method
provides a snapshot of all registered sub-sessions that can be safely iterated
without holding locks. The returned list includes sub-sessions of all types
(stream, datagram, raw) currently managed by this primary session.</p>

<p>Example usage:</p>

<pre><code>subSessions := primary.ListSubSessions()
for _, sub := range subSessions {
    log.Printf(&quot;Sub-session %s (type: %s) is active: %v&quot;, sub.ID(), sub.Type(), sub.Active())
}
</code></pre>

<h4 id="func-primarysession-newdatagram3subsession">func (*PrimarySession) NewDatagram3SubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) NewDatagram3SubSession(id string, options []string) (*Datagram3SubSession, error)
</code></pre>

<p>NewDatagram3SubSession creates a new datagram3 sub-session within this primary
session using SAMv3 UDP forwarding. The sub-session shares the primary session&rsquo;s
I2P identity and tunnel infrastructure while providing full Datagram3Session
functionality for repliable but UNAUTHENTICATED datagram communication. Each
sub-session must have a unique identifier within the primary session scope.</p>

<p>‚ö†Ô∏è SECURITY WARNING: DATAGRAM3 sources are NOT authenticated and can be spoofed!
‚ö†Ô∏è Do not trust source addresses without additional application-level
authentication. ‚ö†Ô∏è If you need authenticated sources, use NewDatagramSubSession
(DATAGRAM) instead.</p>

<p>This implementation uses the SAMv3.3 SESSION ADD protocol to properly register
the subsession with the primary session&rsquo;s SAM connection, ensuring compliance
with the I2P SAM protocol specification for PRIMARY session management.</p>

<p>Per SAMv3.3 specification, DATAGRAM3 subsessions REQUIRE UDP forwarding for
proper operation. Received datagrams contain a 32-byte hash instead of full
authenticated destination. Use the session&rsquo;s hash resolver to convert hashes to
destinations for replies.</p>

<p>Example usage:</p>

<pre><code>datagram3Sub, err := primary.NewDatagram3SubSession(&quot;udp3-handler&quot;, []string{&quot;FROM_PORT=8080&quot;})
reader := datagram3Sub.NewReader()
writer := datagram3Sub.NewWriter()
// Receive datagram with UNAUTHENTICATED source hash
dg, err := reader.ReceiveDatagram()
// Resolve hash to reply (cached by session)
err = dg.ResolveSource(datagram3Sub)
err = writer.SendDatagram([]byte(&quot;reply&quot;), dg.Source)
</code></pre>

<h4 id="func-primarysession-newdatagramsubsession">func (*PrimarySession) NewDatagramSubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) NewDatagramSubSession(id string, options []string) (*DatagramSubSession, error)
</code></pre>

<p>NewDatagramSubSession creates a new datagram sub-session within this primary
session. The sub-session shares the primary session&rsquo;s I2P identity and tunnel
infrastructure while providing full DatagramSession functionality for UDP-like
authenticated messaging. Each sub-session must have a unique identifier within
the primary session scope.</p>

<p>This implementation uses the SAMv3.3 SESSION ADD protocol to properly register
the subsession with the primary session&rsquo;s SAM connection, ensuring compliance
with the I2P SAM protocol specification for PRIMARY session management.</p>

<p>Per SAMv3.3 specification, DATAGRAM subsessions REQUIRE a PORT parameter. If
PORT is not included in the options, PORT=0 (any port) will be added
automatically.</p>

<p>Example usage:</p>

<pre><code>datagramSub, err := primary.NewDatagramSubSession(&quot;udp-handler&quot;, []string{&quot;PORT=8080&quot;, &quot;FROM_PORT=8080&quot;})
writer := datagramSub.NewWriter()
reader := datagramSub.NewReader()
</code></pre>

<h4 id="func-primarysession-newrawsubsession">func (*PrimarySession) NewRawSubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) NewRawSubSession(id string, options []string) (*RawSubSession, error)
</code></pre>

<p>NewRawSubSession creates a new raw sub-session within this primary session using
SAMv3 UDP forwarding. The sub-session shares the primary session&rsquo;s I2P identity
and tunnel infrastructure while providing full RawSession functionality for
unrepliable datagram communication. Each sub-session must have a unique
identifier within the primary session scope.</p>

<p>This implementation uses the SAMv3.3 SESSION ADD protocol to properly register
the subsession with the primary session&rsquo;s SAM connection, ensuring compliance
with the I2P SAM protocol specification for PRIMARY session management.</p>

<p>Per SAMv3.3 specification, RAW subsessions REQUIRE UDP forwarding for proper
operation. V1/V2 TCP control socket reading is no longer supported.</p>

<p>Example usage:</p>

<pre><code>rawSub, err := primary.NewRawSubSession(&quot;raw-sender&quot;, []string{&quot;FROM_PORT=8080&quot;})
writer := rawSub.NewWriter()
reader := rawSub.NewReader()
</code></pre>

<h4 id="func-primarysession-newstreamsubsession">func (*PrimarySession) NewStreamSubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) NewStreamSubSession(id string, options []string) (*StreamSubSession, error)
</code></pre>

<p>NewStreamSubSession creates a new stream sub-session within this primary
session. The sub-session shares the primary session&rsquo;s I2P identity and tunnel
infrastructure while providing full StreamSession functionality for TCP-like
reliable connections. Each sub-session must have a unique identifier within the
primary session scope. Example usage: streamSub, err :=
primary.NewStreamSubSession(&ldquo;tcp-handler&rdquo;, []string{&ldquo;FROM_PORT=8080&rdquo;})</p>

<h4 id="func-primarysession-newuniquestreamsubsession">func (*PrimarySession) NewUniqueStreamSubSession</h4>

<pre><code class="language-go">func (p *PrimarySession) NewUniqueStreamSubSession(s string) (*StreamSubSession, error)
</code></pre>

<p>NewUniqueStreamSubSession creates a new unique stream sub-session within this
primary session.</p>

<h4 id="func-primarysession-subsessioncount">func (*PrimarySession) SubSessionCount</h4>

<pre><code class="language-go">func (p *PrimarySession) SubSessionCount() int
</code></pre>

<p>SubSessionCount returns the number of currently active sub-sessions. This method
provides a quick way to check how many sub-sessions are currently managed by
this primary session across all types.</p>

<p>Example usage:</p>

<pre><code>count := primary.SubSessionCount()
log.Printf(&quot;Primary session managing %d sub-sessions&quot;, count)
</code></pre>

<h4 id="type-primarysessionerror">type PrimarySessionError</h4>

<pre><code class="language-go">type PrimarySessionError struct {
	Op  string // The operation that caused the error
	Err string // The error description
}
</code></pre>

<p>PrimarySessionError represents errors specific to primary session operations. It
provides structured error information with operation context for debugging and
error handling in primary session management scenarios.</p>

<h4 id="func-primarysessionerror-error">func (*PrimarySessionError) Error</h4>

<pre><code class="language-go">func (e *PrimarySessionError) Error() string
</code></pre>

<p>Error implements the error interface for PrimarySessionError. It provides a
formatted error message that includes both the operation context and the
specific error description for clear error reporting.</p>

<h4 id="type-rawsubsession">type RawSubSession</h4>

<pre><code class="language-go">type RawSubSession struct {
	*raw.RawSession
}
</code></pre>

<p>RawSubSession wraps a raw.RawSession to implement the SubSession interface. This
adapter allows RawSession instances to be managed by primary sessions while
maintaining their full functionality and thread-safe operations.</p>

<h4 id="func-newrawsubsession">func  NewRawSubSession</h4>

<pre><code class="language-go">func NewRawSubSession(id string, session *raw.RawSession) *RawSubSession
</code></pre>

<p>NewRawSubSession creates a RawSubSession wrapper around a RawSession. This
constructor initializes the wrapper with proper identification and state
management to enable primary session integration.</p>

<h4 id="func-rawsubsession-active">func (*RawSubSession) Active</h4>

<pre><code class="language-go">func (s *RawSubSession) Active() bool
</code></pre>

<p>Active returns whether this raw sub-session is currently active.</p>

<h4 id="func-rawsubsession-close">func (*RawSubSession) Close</h4>

<pre><code class="language-go">func (s *RawSubSession) Close() error
</code></pre>

<p>Close closes the raw sub-session and marks it as inactive.</p>

<h4 id="func-rawsubsession-id">func (*RawSubSession) ID</h4>

<pre><code class="language-go">func (s *RawSubSession) ID() string
</code></pre>

<p>ID returns the unique identifier for this raw sub-session.</p>

<h4 id="func-rawsubsession-type">func (*RawSubSession) Type</h4>

<pre><code class="language-go">func (s *RawSubSession) Type() string
</code></pre>

<p>Type returns the session type identifier for raw sessions.</p>

<h4 id="type-sam">type SAM</h4>

<pre><code class="language-go">type SAM struct {
	*common.SAM
}
</code></pre>

<p>SAM wraps common.SAM to provide primary session functionality for creating and
managing master sessions that can contain multiple sub-sessions of different
types. This type extends the base SAM functionality with methods specifically
designed for primary session management, including session creation with various
configuration options and signature types. Example usage: sam := &amp;SAM{SAM:
baseSAM}; session, err := sam.NewPrimarySession(id, keys, options)</p>

<h4 id="func-sam-newprimarysession">func (*SAM) NewPrimarySession</h4>

<pre><code class="language-go">func (s *SAM) NewPrimarySession(id string, keys i2pkeys.I2PKeys, options []string) (*PrimarySession, error)
</code></pre>

<p>NewPrimarySession creates a new primary session with the SAM bridge using
default settings. This method establishes a new primary session for managing
multiple sub-sessions over I2P with the specified session ID, cryptographic
keys, and configuration options. It uses default signature settings and provides
a simple interface for basic primary session needs.</p>

<p>The primary session acts as a master container that can create and manage
multiple sub-sessions of different types (stream, datagram, raw) while sharing
the same I2P identity and tunnel infrastructure for enhanced efficiency and
consistent anonymity properties.</p>

<p>Example usage:</p>

<pre><code>session, err := sam.NewPrimarySession(&quot;my-primary&quot;, keys, []string{&quot;inbound.length=2&quot;})
streamSub, err := session.NewStreamSubSession(&quot;stream-1&quot;, streamOptions)
</code></pre>

<h4 id="func-sam-newprimarysessionwithports">func (*SAM) NewPrimarySessionWithPorts</h4>

<pre><code class="language-go">func (s *SAM) NewPrimarySessionWithPorts(id, fromPort, toPort string, keys i2pkeys.I2PKeys, options []string) (*PrimarySession, error)
</code></pre>

<p>NewPrimarySessionWithPorts creates a new primary session with port
specifications. This method allows configuring specific port ranges for the
session, enabling fine-grained control over network communication ports for
advanced routing scenarios. Port configuration is useful for applications
requiring specific port mappings, firewall compatibility, or integration with
existing network infrastructure and service discovery mechanisms.</p>

<p>The primary session created with port configuration maintains full multi-session
management capabilities while using the specified port parameters for network
communication optimization and compatibility with existing network
configurations or security requirements.</p>

<p>Example usage:</p>

<pre><code>session, err := sam.NewPrimarySessionWithPorts(id, &quot;8080&quot;, &quot;8081&quot;, keys, options)
rawSub, err := session.NewRawSubSession(&quot;raw-1&quot;, rawOptions)
</code></pre>

<h4 id="func-sam-newprimarysessionwithsignature">func (*SAM) NewPrimarySessionWithSignature</h4>

<pre><code class="language-go">func (s *SAM) NewPrimarySessionWithSignature(id string, keys i2pkeys.I2PKeys, options []string, sigType string) (*PrimarySession, error)
</code></pre>

<p>NewPrimarySessionWithSignature creates a new primary session with custom
signature type. This method allows specifying a custom cryptographic signature
type for the session, enabling advanced security configurations beyond the
default signature algorithm. Different signature types provide various security
levels, compatibility options, and performance characteristics for different I2P
network requirements.</p>

<p>The primary session created with custom signature maintains the same
multi-session management capabilities while using the specified cryptographic
parameters for enhanced security or compatibility with specific I2P network
configurations.</p>

<p>Example usage:</p>

<pre><code>session, err := sam.NewPrimarySessionWithSignature(id, keys, options, &quot;EdDSA_SHA512_Ed25519&quot;)
datagramSub, err := session.NewDatagramSubSession(&quot;datagram-1&quot;, datagramOptions)
</code></pre>

<h4 id="type-streamsubsession">type StreamSubSession</h4>

<pre><code class="language-go">type StreamSubSession struct {
	*stream.StreamSession
}
</code></pre>

<p>StreamSubSession wraps a stream.StreamSession to implement the SubSession
interface. This adapter allows StreamSession instances to be managed by primary
sessions while maintaining their full functionality and thread-safe operations.</p>

<h4 id="func-newstreamsubsession">func  NewStreamSubSession</h4>

<pre><code class="language-go">func NewStreamSubSession(id string, session *stream.StreamSession) *StreamSubSession
</code></pre>

<p>NewStreamSubSession creates a StreamSubSession wrapper around a StreamSession.
This constructor initializes the wrapper with proper identification and state
management to enable primary session integration.</p>

<h4 id="func-streamsubsession-active">func (*StreamSubSession) Active</h4>

<pre><code class="language-go">func (s *StreamSubSession) Active() bool
</code></pre>

<p>Active returns whether this stream sub-session is currently active.</p>

<h4 id="func-streamsubsession-close">func (*StreamSubSession) Close</h4>

<pre><code class="language-go">func (s *StreamSubSession) Close() error
</code></pre>

<p>Close closes the stream sub-session and marks it as inactive.</p>

<h4 id="func-streamsubsession-id">func (*StreamSubSession) ID</h4>

<pre><code class="language-go">func (s *StreamSubSession) ID() string
</code></pre>

<p>ID returns the unique identifier for this stream sub-session.</p>

<h4 id="func-streamsubsession-type">func (*StreamSubSession) Type</h4>

<pre><code class="language-go">func (s *StreamSubSession) Type() string
</code></pre>

<p>Type returns the session type identifier for stream sessions.</p>

<h4 id="type-subsession">type SubSession</h4>

<pre><code class="language-go">type SubSession interface {
	// ID returns the unique identifier for this sub-session
	ID() string
	// Type returns the session type (&quot;STREAM&quot;, &quot;DATAGRAM&quot;, &quot;DATAGRAM3&quot;, &quot;RAW&quot;)
	Type() string
	// Close closes the sub-session and releases its resources
	Close() error
	// Active returns whether the sub-session is currently active
	Active() bool
}
</code></pre>

<p>SubSession represents a generic interface for sub-sessions that can be managed
by a primary session. All sub-session types (stream, datagram, datagram3, raw)
implement this interface to provide unified lifecycle management and
identification.</p>

<h4 id="type-subsessionregistry">type SubSessionRegistry</h4>

<pre><code class="language-go">type SubSessionRegistry struct {
}
</code></pre>

<p>SubSessionRegistry manages a collection of sub-sessions with thread-safe access.
It maintains mappings between session IDs and their corresponding session
instances, enabling efficient lookup, registration, and cleanup operations for
primary sessions.</p>

<h4 id="func-newsubsessionregistry">func  NewSubSessionRegistry</h4>

<pre><code class="language-go">func NewSubSessionRegistry() *SubSessionRegistry
</code></pre>

<p>NewSubSessionRegistry creates a new registry for managing sub-sessions. It
initializes the internal data structures needed for thread-safe sub-session
management and returns a ready-to-use registry instance.</p>

<h4 id="func-subsessionregistry-close">func (*SubSessionRegistry) Close</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) Close() error
</code></pre>

<p>Close closes the registry and all registered sub-sessions. This method ensures
proper cleanup of all resources and marks the registry as closed to prevent
further operations. It&rsquo;s safe to call multiple times.</p>

<h4 id="func-subsessionregistry-count">func (*SubSessionRegistry) Count</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) Count() int
</code></pre>

<p>Count returns the number of currently registered sub-sessions. This method is
thread-safe and provides a quick way to check registry size.</p>

<h4 id="func-subsessionregistry-get">func (*SubSessionRegistry) Get</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) Get(id string) (SubSession, bool)
</code></pre>

<p>Get retrieves a sub-session by ID from the registry. Returns the session
instance and true if found, or nil and false if not found. This method is
thread-safe and provides read-only access to registered sessions.</p>

<h4 id="func-subsessionregistry-isclosed">func (*SubSessionRegistry) IsClosed</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) IsClosed() bool
</code></pre>

<p>IsClosed returns whether the registry has been closed. This method is
thread-safe and can be used to check registry state.</p>

<h4 id="func-subsessionregistry-list">func (*SubSessionRegistry) List</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) List() []SubSession
</code></pre>

<p>List returns a copy of all currently registered sub-sessions. This method is
thread-safe and returns a snapshot of the registry state that can be safely
iterated without holding locks.</p>

<h4 id="func-subsessionregistry-register">func (*SubSessionRegistry) Register</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) Register(id string, session SubSession) error
</code></pre>

<p>Register adds a sub-session to the registry with the specified ID. Returns an
error if the registry is closed or if a session with the same ID already exists.
This method is thread-safe and can be called concurrently.</p>

<h4 id="func-subsessionregistry-unregister">func (*SubSessionRegistry) Unregister</h4>

<pre><code class="language-go">func (r *SubSessionRegistry) Unregister(id string) error
</code></pre>

<p>Unregister removes a sub-session from the registry by ID. Returns an error if
the registry is closed or if no session with the specified ID exists. This
method is thread-safe and can be called concurrently.</p>

      </div>
    </main>
    
    <footer class="page-footer">
      <p>Generated on 2025-10-26 11:09:37 ‚Ä¢ <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a></p>
    </footer>
  </div>
</body>
</html>