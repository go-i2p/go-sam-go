<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>datagram - go-i2p/go-sam-go</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <nav class="nav-sidebar">
    <div class="repo-info">
      <h2>
        <a href="../index.html">go-i2p/go-sam-go</a>
      </h2>
      <div class="repo-meta">
        üìù 226 commits
        
      </div>
    </div>
    
    <ul class="nav-links">
      <li><a href="../index.html">Repository Overview</a></li>
      
      
        <div class="nav-section-title">Documentation:</div>
        
          <li><a href="../docs/SAMv3.html" >SAM V3</a></li>
        
          <li><a href="../docs/common/DOC.html" >common</a></li>
        
          <li><a href="../docs/datagram/DOC.html" class="active">datagram</a></li>
        
          <li><a href="../docs/datagram2/DOC.html" >datagram2</a></li>
        
          <li><a href="../docs/datagram3/DOC.html" >datagram3</a></li>
        
          <li><a href="../docs/primary/DOC.html" >primary</a></li>
        
          <li><a href="../docs/raw/DOC.html" >raw</a></li>
        
          <li><a href="../docs/DOC.html" >sam3</a></li>
        
          <li><a href="../docs/sigs.html" >sam3</a></li>
        
          <li><a href="../docs/stream/DOC.html" >stream</a></li>
        
      
    </ul>
    
    <div class="nav-footer">
      <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a>
    </div>
  </nav>
  
  <div class="main-content">
    <header class="page-header">
      <h1>datagram - go-i2p/go-sam-go</h1>
    </header>
    
    <main>
      <div class="doc-content">
        <h1 id="datagram">datagram</h1>

<p>&ndash;</p>

<pre><code>import &quot;github.com/go-i2p/go-sam-go/datagram&quot;
</code></pre>

<p>Package datagram provides legacy authenticated datagram sessions for I2P using
SAMv3 DATAGRAM.</p>

<p>DATAGRAM sessions provide authenticated, repliable UDP-like messaging over I2P
tunnels. This is the legacy format without replay protection. For new
applications requiring replay protection, use package datagram2 instead.</p>

<p>Key features:</p>

<pre><code>- Authenticated datagrams with signature verification
- Repliable (can send replies to sender)
- No replay protection (use datagram2 if needed)
- UDP-like messaging (unreliable, unordered)
- Maximum 31744 bytes per datagram (11 KB recommended)
- Implements net.PacketConn interface
</code></pre>

<p>Session creation requires 2-5 minutes for I2P tunnel establishment. Use generous
timeouts and exponential backoff retry logic.</p>

<p>Basic usage:</p>

<pre><code>sam, err := common.NewSAM(&quot;127.0.0.1:7656&quot;)
session, err := datagram.NewDatagramSession(sam, &quot;my-session&quot;, keys, []string{&quot;inbound.length=1&quot;})
defer session.Close()
conn := session.PacketConn()
n, err := conn.WriteTo(data, destination)
n, addr, err := conn.ReadFrom(buffer)
</code></pre>

<p>See also: Package datagram2 (with replay protection), datagram3
(unauthenticated), stream (TCP-like), raw (non-repliable), primary
(multi-session management).</p>

<h2 id="usage">Usage</h2>

<h4 id="type-datagram">type Datagram</h4>

<pre><code class="language-go">type Datagram struct {
	Data   []byte
	Source i2pkeys.I2PAddr
	Local  i2pkeys.I2PAddr
}
</code></pre>

<p>Datagram represents an I2P datagram message containing data and address
information. It encapsulates the payload data along with source and destination
addressing details, providing all necessary information for processing received
datagrams or preparing outgoing ones. The structure includes both the raw data
bytes and I2P address information for routing. Example usage: if
datagram.Source.Base32() == expectedSender { processData(datagram.Data) }</p>

<h4 id="type-datagramaddr">type DatagramAddr</h4>

<pre><code class="language-go">type DatagramAddr struct {
}
</code></pre>

<p>DatagramAddr implements net.Addr interface for I2P datagram addresses. This type
provides standard Go networking address representation for I2P destinations,
allowing seamless integration with existing Go networking code that expects
net.Addr. The address wraps an I2P address and provides string representation
and network type identification. Example usage: addr := &amp;DatagramAddr{addr:
destination}; fmt.Println(addr.Network(), addr.String())</p>

<h4 id="func-datagramaddr-network">func (*DatagramAddr) Network</h4>

<pre><code class="language-go">func (a *DatagramAddr) Network() string
</code></pre>

<p>Network returns the network type for this address. This method implements the
net.Addr interface and always returns &ldquo;i2p-datagram&rdquo; to identify this as an I2P
datagram address type for networking compatibility. Example usage: network :=
addr.Network() // returns &ldquo;i2p-datagram&rdquo;</p>

<h4 id="func-datagramaddr-string">func (*DatagramAddr) String</h4>

<pre><code class="language-go">func (a *DatagramAddr) String() string
</code></pre>

<p>String returns the string representation of the address. This method implements
the net.Addr interface and returns the Base32 encoded representation of the I2P
address for human-readable display and logging. Example usage: addrStr :=
addr.String() // returns &ldquo;abcd1234&hellip;xyz.b32.i2p&rdquo;</p>

<h4 id="type-datagramconn">type DatagramConn</h4>

<pre><code class="language-go">type DatagramConn struct {
}
</code></pre>

<p>DatagramConn implements net.PacketConn interface for I2P datagram communication.
This type provides compatibility with standard Go networking patterns by
wrapping datagram session functionality in a familiar PacketConn interface. It
manages internal readers and writers while providing standard connection
operations. Example usage: conn := session.PacketConn(); n, addr, err :=
conn.ReadFrom(buffer)</p>

<h4 id="func-datagramconn-close">func (*DatagramConn) Close</h4>

<pre><code class="language-go">func (c *DatagramConn) Close() error
</code></pre>

<p>Close closes the datagram connection and releases associated resources. This
method implements the net.Conn interface. It closes the reader and writer but
does not close the underlying session, which may be shared by other connections.
Multiple calls to Close are safe and will return nil after the first call.</p>

<h4 id="func-datagramconn-localaddr">func (*DatagramConn) LocalAddr</h4>

<pre><code class="language-go">func (c *DatagramConn) LocalAddr() net.Addr
</code></pre>

<p>LocalAddr returns the local network address as a DatagramAddr containing the I2P
destination address of this connection&rsquo;s session. This method implements the
net.Conn interface and provides access to the local I2P destination.</p>

<h4 id="func-datagramconn-read">func (*DatagramConn) Read</h4>

<pre><code class="language-go">func (c *DatagramConn) Read(b []byte) (n int, err error)
</code></pre>

<p>Read implements net.Conn by wrapping ReadFrom for stream-like usage. It reads
data into the provided byte slice and returns the number of bytes read. When
reading, it also updates the remote address of the connection for subsequent
Write calls. Note: This is not typical for datagrams which are connectionless,
but provides compatibility with the net.Conn interface.</p>

<h4 id="func-datagramconn-readfrom">func (*DatagramConn) ReadFrom</h4>

<pre><code class="language-go">func (c *DatagramConn) ReadFrom(p []byte) (n int, addr net.Addr, err error)
</code></pre>

<p>ReadFrom reads a datagram from the connection and returns the number of bytes
read, the source address, and any error encountered. This method implements the
net.PacketConn interface. It starts the receive loop if not already started and
blocks until a datagram is received. The data is copied to the provided buffer
p, and the source address is returned as a DatagramAddr.</p>

<h4 id="func-datagramconn-remoteaddr">func (*DatagramConn) RemoteAddr</h4>

<pre><code class="language-go">func (c *DatagramConn) RemoteAddr() net.Addr
</code></pre>

<p>RemoteAddr returns the remote network address of the connection. This method
implements the net.Conn interface. For datagram connections, this returns the
address of the last peer that sent data (set by Read), or nil if no data has
been received yet.</p>

<h4 id="func-datagramconn-setdeadline">func (*DatagramConn) SetDeadline</h4>

<pre><code class="language-go">func (c *DatagramConn) SetDeadline(t time.Time) error
</code></pre>

<p>SetDeadline sets both read and write deadlines for the connection. This method
implements the net.Conn interface by calling both SetReadDeadline and
SetWriteDeadline with the same time value. If either deadline cannot be set, the
first error encountered is returned.</p>

<h4 id="func-datagramconn-setreaddeadline">func (*DatagramConn) SetReadDeadline</h4>

<pre><code class="language-go">func (c *DatagramConn) SetReadDeadline(t time.Time) error
</code></pre>

<p>SetReadDeadline sets the deadline for future ReadFrom calls. This method
implements the net.Conn interface. For datagram connections, this is currently a
placeholder implementation that always returns nil. Timeout handling is managed
differently for datagram operations.</p>

<h4 id="func-datagramconn-setwritedeadline">func (*DatagramConn) SetWriteDeadline</h4>

<pre><code class="language-go">func (c *DatagramConn) SetWriteDeadline(t time.Time) error
</code></pre>

<p>SetWriteDeadline sets the deadline for future WriteTo calls. This method
implements the net.Conn interface. If the deadline is not zero, it calculates
the timeout duration and sets it on the writer for subsequent write operations.</p>

<h4 id="func-datagramconn-write">func (*DatagramConn) Write</h4>

<pre><code class="language-go">func (c *DatagramConn) Write(b []byte) (n int, err error)
</code></pre>

<p>Write implements net.Conn by wrapping WriteTo for stream-like usage. It writes
data to the remote address set by the last Read operation and returns the number
of bytes written. If no remote address has been set, it returns an error. Note:
This is not typical for datagrams which are connectionless, but provides
compatibility with the net.Conn interface.</p>

<h4 id="func-datagramconn-writeto">func (*DatagramConn) WriteTo</h4>

<pre><code class="language-go">func (c *DatagramConn) WriteTo(p []byte, addr net.Addr) (n int, err error)
</code></pre>

<p>WriteTo writes a datagram to the specified address and returns the number of
bytes written and any error encountered. This method implements the
net.PacketConn interface. The address must be a DatagramAddr containing a valid
I2P destination. The entire byte slice p is sent as a single datagram message.</p>

<h4 id="type-datagramlistener">type DatagramListener</h4>

<pre><code class="language-go">type DatagramListener struct {
}
</code></pre>

<p>DatagramListener implements net.Listener for I2P datagram connections. It
provides a way to accept incoming datagram connections in a stream-like manner,
where each accepted connection represents a new DatagramConn that can be used
for bidirectional communication with remote I2P destinations.</p>

<h4 id="func-datagramlistener-accept">func (*DatagramListener) Accept</h4>

<pre><code class="language-go">func (l *DatagramListener) Accept() (net.Conn, error)
</code></pre>

<p>Accept waits for and returns the next datagram connection to the listener. This
method implements the net.Listener interface. It blocks until a new connection
is available or an error occurs. Each accepted connection is a new DatagramConn
that shares the underlying session but has its own reader/writer.</p>

<h4 id="func-datagramlistener-addr">func (*DatagramListener) Addr</h4>

<pre><code class="language-go">func (l *DatagramListener) Addr() net.Addr
</code></pre>

<p>Addr returns the listener&rsquo;s network address as a DatagramAddr. This method
implements the net.Listener interface and provides access to the I2P destination
address that this listener is bound to.</p>

<h4 id="func-datagramlistener-close">func (*DatagramListener) Close</h4>

<pre><code class="language-go">func (l *DatagramListener) Close() error
</code></pre>

<p>Close closes the datagram listener and releases associated resources. This
method implements the net.Listener interface. It stops accepting new connections
and closes the reader. The underlying session is not closed as it may be shared
by other components. Multiple calls to Close are safe.</p>

<h4 id="type-datagramreader">type DatagramReader</h4>

<pre><code class="language-go">type DatagramReader struct {
}
</code></pre>

<p>DatagramReader handles incoming datagram reception from the I2P network. It
provides asynchronous datagram reception through buffered channels, allowing
applications to receive datagrams without blocking. The reader manages its own
goroutine for continuous message processing and provides thread-safe access to
received datagrams. Example usage: reader := session.NewReader(); datagram, err
:= reader.ReceiveDatagram()</p>

<h4 id="func-datagramreader-close">func (*DatagramReader) Close</h4>

<pre><code class="language-go">func (r *DatagramReader) Close() error
</code></pre>

<p>Close closes the DatagramReader and stops its receive loop. This method safely
terminates the reader, cleans up all associated resources, and signals any
waiting goroutines to stop. It&rsquo;s safe to call multiple times and will not block
if the reader is already closed. Example usage: defer reader.Close()</p>

<h4 id="func-datagramreader-receivedatagram">func (*DatagramReader) ReceiveDatagram</h4>

<pre><code class="language-go">func (r *DatagramReader) ReceiveDatagram() (*Datagram, error)
</code></pre>

<p>ReceiveDatagram receives a single datagram from the I2P network. This method
blocks until a datagram is received or an error occurs, returning the received
datagram with its data and addressing information. It handles concurrent access
safely and provides proper error handling for network issues. Example usage:
datagram, err := reader.ReceiveDatagram()</p>

<h4 id="type-datagramsession">type DatagramSession</h4>

<pre><code class="language-go">type DatagramSession struct {
	*common.BaseSession
}
</code></pre>

<p>DatagramSession represents a datagram session that can send and receive
datagrams over I2P. This session type provides UDP-like messaging capabilities
through the I2P network, allowing applications to send and receive datagrams
with message reliability and ordering guarantees. The session manages the
underlying I2P connection and provides methods for creating readers and writers.
For PRIMARY subsessions, it can use UDP forwarding mode where datagrams are
received via UDP socket. Example usage: session, err := NewDatagramSession(sam,
&ldquo;my-session&rdquo;, keys, options)</p>

<h4 id="func-newdatagramsession">func  NewDatagramSession</h4>

<pre><code class="language-go">func NewDatagramSession(sam *common.SAM, id string, keys i2pkeys.I2PKeys, options []string) (*DatagramSession, error)
</code></pre>

<p>NewDatagramSession creates a new datagram session for UDP-like I2P messaging
using SAMv3 UDP forwarding. This function establishes a new datagram session
with the provided SAM connection, session ID, cryptographic keys, and
configuration options. It automatically creates a UDP listener for receiving
forwarded datagrams (SAMv3 requirement) and configures the session with
PORT/HOST parameters. V1/V2 compatibility (reading from TCP control socket) is
no longer supported. Returns a DatagramSession instance that uses UDP forwarding
for all datagram reception. Example usage: session, err :=
NewDatagramSession(sam, &ldquo;my-session&rdquo;, keys, []string{&ldquo;inbound.length=1&rdquo;})</p>

<h4 id="func-newdatagramsessionfromsubsession">func  NewDatagramSessionFromSubsession</h4>

<pre><code class="language-go">func NewDatagramSessionFromSubsession(sam *common.SAM, id string, keys i2pkeys.I2PKeys, options []string, udpConn *net.UDPConn) (*DatagramSession, error)
</code></pre>

<p>NewDatagramSessionFromSubsession creates a DatagramSession for a subsession that
has already been registered with a PRIMARY session using SESSION ADD. This
constructor skips the session creation step since the subsession is already
registered with the SAM bridge.</p>

<p>This function is specifically designed for use with SAMv3.3 PRIMARY sessions
where subsessions are created using SESSION ADD rather than SESSION CREATE
commands.</p>

<p>For PRIMARY datagram subsessions, UDP forwarding is mandatory (SAMv3
requirement). The UDP connection must be provided for proper datagram reception
via UDP forwarding.</p>

<p>Parameters:</p>

<pre><code>- sam: SAM connection for data operations (separate from the primary session's control connection)
- id: The subsession ID that was already registered with SESSION ADD
- keys: The I2P keys from the primary session (shared across all subsessions)
- options: Configuration options for the subsession
- udpConn: UDP connection for receiving forwarded datagrams (required, not nil)
</code></pre>

<p>Returns a DatagramSession ready for use without attempting to create a new SAM
session.</p>

<h4 id="func-datagramsession-addr">func (*DatagramSession) Addr</h4>

<pre><code class="language-go">func (s *DatagramSession) Addr() i2pkeys.I2PAddr
</code></pre>

<p>Addr returns the I2P address of this session. This address represents the
session&rsquo;s identity on the I2P network and can be used by other nodes to send
datagrams to this session. The address is derived from the session&rsquo;s
cryptographic keys. Example usage: myAddr := session.Addr(); fmt.Println(&ldquo;My I2P
address:&rdquo;, myAddr.Base32())</p>

<h4 id="func-datagramsession-close">func (*DatagramSession) Close</h4>

<pre><code class="language-go">func (s *DatagramSession) Close() error
</code></pre>

<p>Close closes the datagram session and all associated resources. This method
safely terminates the session, closes the UDP listener and underlying
connection, and cleans up any background goroutines. It&rsquo;s safe to call multiple
times. Example usage: defer session.Close()</p>

<h4 id="func-datagramsession-dial">func (*DatagramSession) Dial</h4>

<pre><code class="language-go">func (ds *DatagramSession) Dial(destination string) (net.PacketConn, error)
</code></pre>

<p>Dial establishes a datagram connection to the specified I2P destination. This
method creates a net.PacketConn interface for sending and receiving datagrams
with the specified destination. It uses a default timeout of 30 seconds for
connection establishment and provides UDP-like communication over I2P networks.
Example usage: conn, err := session.Dial(&ldquo;destination.b32.i2p&rdquo;)</p>

<h4 id="func-datagramsession-dialcontext">func (*DatagramSession) DialContext</h4>

<pre><code class="language-go">func (ds *DatagramSession) DialContext(ctx context.Context, destination string) (net.PacketConn, error)
</code></pre>

<p>DialContext establishes a datagram connection with context support for
cancellation. This method provides the core dialing functionality with
context-based cancellation support, allowing for proper resource cleanup and
operation cancellation through the provided context. It validates the
destination and session state before attempting connection establishment.
Example usage: conn, err := session.DialContext(ctx, &ldquo;destination.b32.i2p&rdquo;)</p>

<h4 id="func-datagramsession-diali2p">func (*DatagramSession) DialI2P</h4>

<pre><code class="language-go">func (ds *DatagramSession) DialI2P(addr i2pkeys.I2PAddr) (net.PacketConn, error)
</code></pre>

<p>DialI2P establishes a datagram connection to an I2P address using native
addressing. This method creates a net.PacketConn interface for communicating
with the specified I2P address using the native i2pkeys.I2PAddr type. It uses a
default timeout of 30 seconds and provides type-safe addressing for I2P
destinations. Example usage: conn, err := session.DialI2P(i2pAddress)</p>

<h4 id="func-datagramsession-diali2pcontext">func (*DatagramSession) DialI2PContext</h4>

<pre><code class="language-go">func (ds *DatagramSession) DialI2PContext(ctx context.Context, addr i2pkeys.I2PAddr) (net.PacketConn, error)
</code></pre>

<p>DialI2PContext establishes a datagram connection to an I2P address with context
support. This method provides the core I2P dialing functionality with
context-based cancellation, allowing for proper resource cleanup and operation
cancellation through the provided context. It validates the session state and
creates a connection with integrated reader and writer. Example usage: conn, err
:= session.DialI2PContext(ctx, i2pAddress)</p>

<h4 id="func-datagramsession-diali2ptimeout">func (*DatagramSession) DialI2PTimeout</h4>

<pre><code class="language-go">func (ds *DatagramSession) DialI2PTimeout(addr i2pkeys.I2PAddr, timeout time.Duration) (net.PacketConn, error)
</code></pre>

<p>DialI2PTimeout establishes a datagram connection to an I2P address with timeout.
This method provides time-bounded connection establishment using native I2P
addressing. Zero or negative timeout values disable the timeout mechanism. The
timeout only applies to the initial connection setup, not to subsequent datagram
operations. Example usage: conn, err := session.DialI2PTimeout(i2pAddress,
60*time.Second)</p>

<h4 id="func-datagramsession-dialtimeout">func (*DatagramSession) DialTimeout</h4>

<pre><code class="language-go">func (ds *DatagramSession) DialTimeout(destination string, timeout time.Duration) (net.PacketConn, error)
</code></pre>

<p>DialTimeout establishes a datagram connection with specified timeout duration.
This method creates a net.PacketConn interface with timeout support for
connection establishment. Zero or negative timeout values disable the timeout
mechanism. The timeout only applies to the initial connection setup, not to
subsequent operations. Example usage: conn, err :=
session.DialTimeout(&ldquo;destination.b32.i2p&rdquo;, 60*time.Second)</p>

<h4 id="func-datagramsession-listen">func (*DatagramSession) Listen</h4>

<pre><code class="language-go">func (s *DatagramSession) Listen() (*DatagramListener, error)
</code></pre>

<p>Listen creates a new DatagramListener for accepting incoming connections. This
method creates a listener that can accept multiple concurrent datagram
connections on the same session. Each accepted connection will be a separate
DatagramConn that shares the underlying session but has its own reader/writer.
The listener starts an accept loop in a goroutine to handle incoming
connections.</p>

<h4 id="func-datagramsession-newreader">func (*DatagramSession) NewReader</h4>

<pre><code class="language-go">func (s *DatagramSession) NewReader() *DatagramReader
</code></pre>

<p>NewReader creates a DatagramReader for receiving datagrams from any source. This
method initializes a new reader with buffered channels for asynchronous datagram
reception. The reader must be started manually with receiveLoop() for continuous
operation. Example usage: reader := session.NewReader(); go
reader.receiveLoop(); datagram, err := reader.ReceiveDatagram()</p>

<h4 id="func-datagramsession-newwriter">func (*DatagramSession) NewWriter</h4>

<pre><code class="language-go">func (s *DatagramSession) NewWriter() *DatagramWriter
</code></pre>

<p>NewWriter creates a DatagramWriter for sending datagrams to specific
destinations. This method initializes a new writer with a default timeout of 30
seconds for send operations. The timeout can be customized using the SetTimeout
method on the returned writer. Example usage: writer :=
session.NewWriter().SetTimeout(60*time.Second); err := writer.SendDatagram(data,
dest)</p>

<h4 id="func-datagramsession-packetconn">func (*DatagramSession) PacketConn</h4>

<pre><code class="language-go">func (s *DatagramSession) PacketConn() net.PacketConn
</code></pre>

<p>PacketConn returns a net.PacketConn interface for this session. This method
provides compatibility with standard Go networking code by wrapping the datagram
session in a connection that implements the PacketConn interface. Example usage:
conn := session.PacketConn(); n, addr, err := conn.ReadFrom(buffer)</p>

<h4 id="func-datagramsession-readfrom">func (*DatagramSession) ReadFrom</h4>

<pre><code class="language-go">func (ds *DatagramSession) ReadFrom(p []byte) (n int, addr net.Addr, err error)
</code></pre>

<p>ReadFrom reads a datagram message from the session, storing it in p. It returns
the number of bytes read (n), the sender&rsquo;s I2P address (addr), and any error
encountered (err). The address can be used to reply to the sender.</p>

<p>The method blocks until a datagram is available or an error occurs. If the
provided buffer p is too small to hold the incoming datagram, the excess data
will be discarded, and n will be set to the buffer size.</p>

<p>Example usage:</p>

<pre><code>n, addr, err := ds.ReadFrom(buf)
if err != nil {
    // handle error
}
fmt.Printf(&quot;Received %d bytes from %s\n&quot;, n, addr.Base32())
</code></pre>

<h4 id="func-datagramsession-receivedatagram">func (*DatagramSession) ReceiveDatagram</h4>

<pre><code class="language-go">func (s *DatagramSession) ReceiveDatagram() (*Datagram, error)
</code></pre>

<p>ReceiveDatagram receives a single datagram from the I2P network. This method is
a convenience wrapper that performs a direct single read operation without
starting a continuous receive loop. For continuous reception, use NewReader()
and manage the reader lifecycle manually. Example usage: datagram, err :=
session.ReceiveDatagram()</p>

<h4 id="func-datagramsession-senddatagram">func (*DatagramSession) SendDatagram</h4>

<pre><code class="language-go">func (s *DatagramSession) SendDatagram(data []byte, dest i2pkeys.I2PAddr) error
</code></pre>

<p>SendDatagram sends a datagram to the specified destination address. This is a
convenience method that creates a temporary writer and sends the datagram
immediately. For multiple sends, it&rsquo;s more efficient to create a writer once and
reuse it. Example usage: err := session.SendDatagram([]byte(&ldquo;hello&rdquo;),
destinationAddr)</p>

<h4 id="func-datagramsession-writeto">func (*DatagramSession) WriteTo</h4>

<pre><code class="language-go">func (ds *DatagramSession) WriteTo(p []byte, addr net.Addr) (n int, err error)
</code></pre>

<p>WriteTo sends a datagram message to the specified I2P address. It returns the
number of bytes written (n) and any error encountered (err).</p>

<p>The returned n may be less than len(p) if the message was truncated to fit the
maximum datagram size limit.</p>

<p>The error return value may indicate:</p>

<pre><code>- SAM protocol errors (e.g., malformed commands, protocol violations, or non-OK responses)
- I2P network errors (e.g., tunnel not established, network unreachable, or timeouts)
- Application errors (e.g., nil session, invalid address type, or session not connected)
</code></pre>

<p>The method may block until the message is sent or an error occurs. If the
message is larger than the maximum allowed datagram size, it will be truncated
to fit within the limit.</p>

<p>Example usage:</p>

<pre><code>n, err := ds.WriteTo([]byte(&quot;Hello, I2P!&quot;), addr)
if err != nil {
    // handle error
}
fmt.Printf(&quot;Sent %d bytes to %s\n&quot;, n, addr.Base32())
</code></pre>

<h4 id="type-datagramwriter">type DatagramWriter</h4>

<pre><code class="language-go">type DatagramWriter struct {
}
</code></pre>

<p>DatagramWriter handles outgoing datagram transmission to I2P destinations. It
provides methods for sending datagrams with configurable timeouts and handles
the underlying SAM protocol communication for message delivery. The writer
supports method chaining for configuration and provides error handling for send
operations. Example usage: writer :=
session.NewWriter().SetTimeout(30*time.Second); err := writer.SendDatagram(data,
dest)</p>

<h4 id="func-datagramwriter-senddatagram">func (*DatagramWriter) SendDatagram</h4>

<pre><code class="language-go">func (w *DatagramWriter) SendDatagram(data []byte, dest i2pkeys.I2PAddr) error
</code></pre>

<p>SendDatagram sends a datagram to the specified I2P destination address. This
method uses the preferred SAMv3 approach: sending via UDP socket to port 7655
rather than using the DATAGRAM SEND command on the SAM bridge socket. It blocks
until the datagram is sent or an error occurs, respecting the configured
timeout. Example usage: err := writer.SendDatagram([]byte(&ldquo;hello world&rdquo;),
destinationAddr)</p>

<h4 id="func-datagramwriter-settimeout">func (*DatagramWriter) SetTimeout</h4>

<pre><code class="language-go">func (w *DatagramWriter) SetTimeout(timeout time.Duration) *DatagramWriter
</code></pre>

<p>SetTimeout sets the timeout for datagram write operations. This method
configures the maximum time to wait for datagram send operations to complete.
The timeout prevents indefinite blocking during network congestion or connection
issues. Returns the writer instance for method chaining convenience. Example
usage: writer.SetTimeout(30*time.Second).SendDatagram(data, destination)</p>

<h4 id="type-sam">type SAM</h4>

<pre><code class="language-go">type SAM struct {
	*common.SAM
}
</code></pre>

<p>SAM wraps common.SAM to provide datagram-specific functionality for I2P
messaging. This type extends the base SAM functionality with methods
specifically designed for datagram communication, including session creation
with various configuration options and signature types for enhanced security and
routing control. Example usage: sam := &amp;SAM{SAM: baseSAM}; session, err :=
sam.NewDatagramSession(id, keys, options)</p>

<h4 id="func-sam-newdatagramsession">func (*SAM) NewDatagramSession</h4>

<pre><code class="language-go">func (s *SAM) NewDatagramSession(id string, keys i2pkeys.I2PKeys, options []string) (*DatagramSession, error)
</code></pre>

<p>NewDatagramSession creates a new datagram session with the SAM bridge using
default settings. This method establishes a new datagram session for UDP-like
messaging over I2P with the specified session ID, cryptographic keys, and
configuration options. It uses default signature settings and provides a simple
interface for basic datagram communication needs. Example usage: session, err :=
sam.NewDatagramSession(&ldquo;my-session&rdquo;, keys, []string{&ldquo;inbound.length=1&rdquo;})</p>

<h4 id="func-sam-newdatagramsessionwithports">func (*SAM) NewDatagramSessionWithPorts</h4>

<pre><code class="language-go">func (s *SAM) NewDatagramSessionWithPorts(id, fromPort, toPort string, keys i2pkeys.I2PKeys, options []string) (*DatagramSession, error)
</code></pre>

<p>NewDatagramSessionWithPorts creates a new datagram session with port
specifications. This method allows configuring specific port ranges for the
session, enabling fine-grained control over network communication ports for
advanced routing scenarios. Port configuration is useful for applications
requiring specific port mappings or firewall compatibility. This function
creates a UDP listener for SAMv3 UDP forwarding (required for v3-only mode).
Example usage: session, err := sam.NewDatagramSessionWithPorts(id, &ldquo;8080&rdquo;,
&ldquo;8081&rdquo;, keys, options)</p>

<h4 id="func-sam-newdatagramsessionwithsignature">func (*SAM) NewDatagramSessionWithSignature</h4>

<pre><code class="language-go">func (s *SAM) NewDatagramSessionWithSignature(id string, keys i2pkeys.I2PKeys, options []string, sigType string) (*DatagramSession, error)
</code></pre>

<p>NewDatagramSessionWithSignature creates a new datagram session with custom
signature type. This method allows specifying a custom cryptographic signature
type for the session, enabling advanced security configurations beyond the
default signature algorithm. Different signature types provide various security
levels and compatibility options. Example usage: session, err :=
sam.NewDatagramSessionWithSignature(id, keys, options, &ldquo;EdDSA_SHA512_Ed25519&rdquo;)</p>

      </div>
    </main>
    
    <footer class="page-footer">
      <p>Generated on 2025-11-09 06:18:15 ‚Ä¢ <a href="https://github.com/go-i2p/go-sam-go" target="_blank">View on GitHub</a></p>
    </footer>
  </div>
</body>
</html>